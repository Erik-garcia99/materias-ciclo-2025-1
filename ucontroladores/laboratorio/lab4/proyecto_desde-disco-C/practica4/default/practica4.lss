
practica4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00800200  000002c4  00000338  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000002c4  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .debug_aranges 00000040  00000000  00000000  00000358  2**3
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 0000005a  00000000  00000000  00000398  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   0000021c  00000000  00000000  000003f2  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000012b  00000000  00000000  0000060e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   0000027f  00000000  00000000  00000739  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000060  00000000  00000000  000009b8  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000010d  00000000  00000000  00000a18  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000094  00000000  00000000  00000b25  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  10:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  14:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  18:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  1c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  20:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  24:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  28:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  2c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  30:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  34:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  38:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  3c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  40:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  44:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  48:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  4c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  50:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  54:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  58:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  5c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  60:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  64:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  68:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  6c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  70:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  74:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  78:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  7c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  80:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  84:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  88:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  8c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  90:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  94:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  98:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  9c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  ac:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  bc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  cc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  dc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  e0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	e4 ec       	ldi	r30, 0xC4	; 196
  fc:	f2 e0       	ldi	r31, 0x02	; 2
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	ac 31       	cpi	r26, 0x1C	; 28
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
 10e:	0e 94 f8 00 	call	0x1f0	; 0x1f0 <main>
 112:	0c 94 60 01 	jmp	0x2c0	; 0x2c0 <_exit>

00000116 <__bad_interrupt>:
 116:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000011a <InitPorts>:
void InitPorts(void)
{

	// conn 1 es salida, con 0 es entrada

	DDRK &= ~(1 << BTN_PIN);
 11a:	e7 e0       	ldi	r30, 0x07	; 7
 11c:	f1 e0       	ldi	r31, 0x01	; 1
 11e:	80 81       	ld	r24, Z
 120:	8e 7f       	andi	r24, 0xFE	; 254
 122:	80 83       	st	Z, r24
	//PORTK &= ~(1 << BTN_PIN); //habilita o deshabilitas los pull-up's internos

	DDRE |= (1 << SEND_PIN);
 124:	69 9a       	sbi	0x0d, 1	; 13
}
 126:	08 95       	ret

00000128 <sendByte>:
	}

}


void sendByte(uint8_t data){
 128:	0f 93       	push	r16
 12a:	1f 93       	push	r17
 12c:	08 2f       	mov	r16, r24


	//paso 1, poner PE1 en 0 logico 
	ClrBitPort(PORTE, 1);
 12e:	71 98       	cbi	0x0e, 1	; 14
	delay_103us();
 130:	0e 94 18 01 	call	0x230	; 0x230 <delay_103us>
 134:	10 e0       	ldi	r17, 0x00	; 0

	for(uint8_t idx=0; idx  < 8; idx++){
	
		if(data & 0x01){
 136:	00 ff       	sbrs	r16, 0
 138:	02 c0       	rjmp	.+4      	; 0x13e <sendByte+0x16>
			SetBitPort(PORTE,1);
 13a:	71 9a       	sbi	0x0e, 1	; 14
 13c:	01 c0       	rjmp	.+2      	; 0x140 <sendByte+0x18>
		}
		else{
			ClrBitPort(PORTE, 1);
 13e:	71 98       	cbi	0x0e, 1	; 14
		}

		delay_103us();
 140:	0e 94 18 01 	call	0x230	; 0x230 <delay_103us>

	//paso 1, poner PE1 en 0 logico 
	ClrBitPort(PORTE, 1);
	delay_103us();

	for(uint8_t idx=0; idx  < 8; idx++){
 144:	1f 5f       	subi	r17, 0xFF	; 255
 146:	18 30       	cpi	r17, 0x08	; 8
 148:	11 f0       	breq	.+4      	; 0x14e <sendByte+0x26>
		else{
			ClrBitPort(PORTE, 1);
		}

		delay_103us();
		data >>=  1;
 14a:	06 95       	lsr	r16
 14c:	f4 cf       	rjmp	.-24     	; 0x136 <sendByte+0xe>
	}

	
	SetBitPort(PORTE,1);
 14e:	71 9a       	sbi	0x0e, 1	; 14
	delay_103us();
 150:	0e 94 18 01 	call	0x230	; 0x230 <delay_103us>


}
 154:	1f 91       	pop	r17
 156:	0f 91       	pop	r16
 158:	08 95       	ret

0000015a <sendData>:

	return 0;
}


void sendData(uint8_t *data){
 15a:	1f 93       	push	r17
 15c:	cf 93       	push	r28
 15e:	df 93       	push	r29
 160:	ec 01       	movw	r28, r24
 162:	10 e0       	ldi	r17, 0x00	; 0
 164:	03 c0       	rjmp	.+6      	; 0x16c <sendData+0x12>

	uint8_t i=0;

	while(data[i]!=0x00){
	
		sendByte(data[i]);
 166:	0e 94 94 00 	call	0x128	; 0x128 <sendByte>
		i++;
 16a:	1f 5f       	subi	r17, 0xFF	; 255
	//perimo es calcular cunatos elementos tiene este arreglo, ahora se que 
	//tiene esos pero pueden ser mas o menos 

	uint8_t i=0;

	while(data[i]!=0x00){
 16c:	fe 01       	movw	r30, r28
 16e:	e1 0f       	add	r30, r17
 170:	f1 1d       	adc	r31, r1
 172:	80 81       	ld	r24, Z
 174:	88 23       	and	r24, r24
 176:	b9 f7       	brne	.-18     	; 0x166 <sendData+0xc>
		sendByte(data[i]);
		i++;
	
	}

}
 178:	df 91       	pop	r29
 17a:	cf 91       	pop	r28
 17c:	1f 91       	pop	r17
 17e:	08 95       	ret

00000180 <check_Btn>:

	DDRE |= (1 << SEND_PIN);
}

uint8_t check_Btn(void)
{
 180:	cf 93       	push	r28
 182:	df 93       	push	r29

	// el circuoto del boton esta en pull - up, por lo que para verificar si el boton
	// esta presionado o no, no presiondado = 1 - HIGH
	//  presionado = 0 - LOW

	if (PINK & (1 << BTN_PIN))
 184:	80 91 06 01 	lds	r24, 0x0106
 188:	80 fd       	sbrc	r24, 0
 18a:	2e c0       	rjmp	.+92     	; 0x1e8 <check_Btn+0x68>
		return 0;
	}

	// PINx lee el estado fisico del pin

	delay(20); // esperar 20 ms antes de actuar
 18c:	84 e1       	ldi	r24, 0x14	; 20
 18e:	90 e0       	ldi	r25, 0x00	; 0
 190:	0e 94 3d 01 	call	0x27a	; 0x27a <delay>

	if (PINK & (1 << BTN_PIN))
 194:	80 91 06 01 	lds	r24, 0x0106
 198:	80 fd       	sbrc	r24, 0
 19a:	26 c0       	rjmp	.+76     	; 0x1e8 <check_Btn+0x68>
 19c:	c0 e0       	ldi	r28, 0x00	; 0
 19e:	d0 e0       	ldi	r29, 0x00	; 0
	uint16_t tiempo_presionado = 0;

	while (1)
	{

		delay(1);
 1a0:	81 e0       	ldi	r24, 0x01	; 1
 1a2:	90 e0       	ldi	r25, 0x00	; 0
 1a4:	0e 94 3d 01 	call	0x27a	; 0x27a <delay>
		tiempo_presionado++;

		if (PINK & (1 << BTN_PIN))
 1a8:	80 91 06 01 	lds	r24, 0x0106
 1ac:	80 fd       	sbrc	r24, 0
 1ae:	14 c0       	rjmp	.+40     	; 0x1d8 <check_Btn+0x58>

	while (1)
	{

		delay(1);
		tiempo_presionado++;
 1b0:	21 96       	adiw	r28, 0x01	; 1
			break;
		}

		// si se superoa el segundo se detecta como largo

		if (tiempo_presionado >= 1000)
 1b2:	83 e0       	ldi	r24, 0x03	; 3
 1b4:	c8 3e       	cpi	r28, 0xE8	; 232
 1b6:	d8 07       	cpc	r29, r24
 1b8:	99 f7       	brne	.-26     	; 0x1a0 <check_Btn+0x20>
 1ba:	04 c0       	rjmp	.+8      	; 0x1c4 <check_Btn+0x44>
		{

			//
			while (!(PINK & (1 << BTN_PIN)))
			{
				delay(1);
 1bc:	81 e0       	ldi	r24, 0x01	; 1
 1be:	90 e0       	ldi	r25, 0x00	; 0
 1c0:	0e 94 3d 01 	call	0x27a	; 0x27a <delay>

		if (tiempo_presionado >= 1000)
		{

			//
			while (!(PINK & (1 << BTN_PIN)))
 1c4:	80 91 06 01 	lds	r24, 0x0106
 1c8:	80 ff       	sbrs	r24, 0
 1ca:	f8 cf       	rjmp	.-16     	; 0x1bc <check_Btn+0x3c>
			{
				delay(1);
			}
			delay(20);
 1cc:	84 e1       	ldi	r24, 0x14	; 20
 1ce:	90 e0       	ldi	r25, 0x00	; 0
 1d0:	0e 94 3d 01 	call	0x27a	; 0x27a <delay>
 1d4:	82 e0       	ldi	r24, 0x02	; 2
 1d6:	09 c0       	rjmp	.+18     	; 0x1ea <check_Btn+0x6a>
			return LONG_PRESSED;
		}
	}

	delay(20);
 1d8:	84 e1       	ldi	r24, 0x14	; 20
 1da:	90 e0       	ldi	r25, 0x00	; 0
 1dc:	0e 94 3d 01 	call	0x27a	; 0x27a <delay>
	if (PINK & (1 << BTN_PIN))
 1e0:	80 91 06 01 	lds	r24, 0x0106
 1e4:	81 70       	andi	r24, 0x01	; 1
 1e6:	01 c0       	rjmp	.+2      	; 0x1ea <check_Btn+0x6a>
 1e8:	80 e0       	ldi	r24, 0x00	; 0

		return SHORT_PRESSED;
	}

	return 0;
}
 1ea:	df 91       	pop	r29
 1ec:	cf 91       	pop	r28
 1ee:	08 95       	ret

000001f0 <main>:
		{0x53, 0x68, 0x6f, 0x72, 0x74, 0x20, 0x70, 0x72, 0x65, 0x73, 0x73, 0x0D, 0x0A, 0x00},
		{0x4c, 0x6f, 0x6e, 0x67, 0x20, 0x70, 0x72, 0x65, 0x73, 0x73, 0x21, 0x0D, 0x0A, 0x00}};

int main(void)
{
	UCSR0B &= ~(1 << TXEN0); // Disable UART-TX
 1f0:	80 91 c1 00 	lds	r24, 0x00C1
 1f4:	87 7f       	andi	r24, 0xF7	; 247
 1f6:	80 93 c1 00 	sts	0x00C1, r24
void InitPorts(void)
{

	// conn 1 es salida, con 0 es entrada

	DDRK &= ~(1 << BTN_PIN);
 1fa:	80 91 07 01 	lds	r24, 0x0107
 1fe:	8e 7f       	andi	r24, 0xFE	; 254
 200:	80 93 07 01 	sts	0x0107, r24
	//PORTK &= ~(1 << BTN_PIN); //habilita o deshabilitas los pull-up's internos

	DDRE |= (1 << SEND_PIN);
 204:	69 9a       	sbi	0x0d, 1	; 13
void InitPorts(void)
{

	// conn 1 es salida, con 0 es entrada

	DDRK &= ~(1 << BTN_PIN);
 206:	80 91 07 01 	lds	r24, 0x0107
 20a:	8e 7f       	andi	r24, 0xFE	; 254
 20c:	80 93 07 01 	sts	0x0107, r24
	//PORTK &= ~(1 << BTN_PIN); //habilita o deshabilitas los pull-up's internos

	DDRE |= (1 << SEND_PIN);
 210:	69 9a       	sbi	0x0d, 1	; 13
	}*/

	InitPorts();
	while (1)
	{
		switch (check_Btn())
 212:	0e 94 c0 00 	call	0x180	; 0x180 <check_Btn>
 216:	81 30       	cpi	r24, 0x01	; 1
 218:	19 f0       	breq	.+6      	; 0x220 <main+0x30>
 21a:	82 30       	cpi	r24, 0x02	; 2
 21c:	d1 f7       	brne	.-12     	; 0x212 <main+0x22>
 21e:	03 c0       	rjmp	.+6      	; 0x226 <main+0x36>
		{
		case eBtnShortPressed:
		{
			sendData(data[0]);
 220:	80 e0       	ldi	r24, 0x00	; 0
 222:	92 e0       	ldi	r25, 0x02	; 2
 224:	02 c0       	rjmp	.+4      	; 0x22a <main+0x3a>
			break;
		}
		case eBtnLongPressed:
		{
			sendData(data[1]);
 226:	8e e0       	ldi	r24, 0x0E	; 14
 228:	92 e0       	ldi	r25, 0x02	; 2
 22a:	0e 94 ad 00 	call	0x15a	; 0x15a <sendData>
 22e:	f1 cf       	rjmp	.-30     	; 0x212 <main+0x22>

00000230 <delay_103us>:


delay_103us:


	nop
 230:	00 00       	nop
	nop	
 232:	00 00       	nop


	ldi r22,5 
 234:	65 e0       	ldi	r22, 0x05	; 5
	ldi r21, 7
 236:	57 e0       	ldi	r21, 0x07	; 7

00000238 <nxt0>:
	
nxt0:
	nop 
 238:	00 00       	nop
	nop
 23a:	00 00       	nop
	nop 
 23c:	00 00       	nop
	ldi r20, 8 
 23e:	48 e0       	ldi	r20, 0x08	; 8

00000240 <nxt1>:

	
nxt1:
	dec r21 
 240:	5a 95       	dec	r21
	nop 
 242:	00 00       	nop
	nop 
 244:	00 00       	nop
	brne nxt1 
 246:	e1 f7       	brne	.-8      	; 0x240 <nxt1>

00000248 <nxt2>:
	
nxt2:
	ldi r21,7 
 248:	57 e0       	ldi	r21, 0x07	; 7
	nop 
 24a:	00 00       	nop
	nop
 24c:	00 00       	nop
	dec r20	
 24e:	4a 95       	dec	r20
	brne nxt1 
 250:	b9 f7       	brne	.-18     	; 0x240 <nxt1>

	dec r22 
 252:	6a 95       	dec	r22
	nop 
 254:	00 00       	nop
	brne nxt0 
 256:	81 f7       	brne	.-32     	; 0x238 <nxt0>

	ret 
 258:	08 95       	ret

0000025a <delay1S>:


delay1S:

ldi r20, 241;	
 25a:	41 ef       	ldi	r20, 0xF1	; 241
	...

0000025e <nxt_S>:
	nop				;1 	
		nxt_S: ldi r21, 144;  		/x
 25e:	50 e9       	ldi	r21, 0x90	; 144
		nop;						/x
 260:	00 00       	nop
		nop;						/x
 262:	00 00       	nop
	...

00000266 <nxt2_S>:
		nop;						/x
			nxt2_S:ldi r22, 152 ; 	/xy
 266:	68 e9       	ldi	r22, 0x98	; 152
			nop;					/xy
 268:	00 00       	nop
	...

0000026c <nxt3_S>:
			nop;					/xy
				nxt3_S:dec r22; 	/xyz
 26c:	6a 95       	dec	r22
				brne nxt3_S;	 	/xy(2z-1)
 26e:	f1 f7       	brne	.-4      	; 0x26c <nxt3_S>
			dec r21; 				/xy
 270:	5a 95       	dec	r21
			brne nxt2_S;	 		/x(2y-1)
 272:	c9 f7       	brne	.-14     	; 0x266 <nxt2_S>
		dec r20;	 				/x
 274:	4a 95       	dec	r20
		brne nxt_S;		 			/2x-1
 276:	99 f7       	brne	.-26     	; 0x25e <nxt_S>


	ret
 278:	08 95       	ret

0000027a <delay>:
delay:

	; en este tendre que hacer muchos descuentos por esto de
	;cunado sea 0 y  lo demas 

	cpi r24, 0x00 ; 1 
 27a:	80 30       	cpi	r24, 0x00	; 0
	breq final ;2 - 1
 27c:	49 f0       	breq	.+18     	; 0x290 <final>

	cpi r24, 0x01
 27e:	81 30       	cpi	r24, 0x01	; 1
	breq un_mSeg; si r24 es 1 ms entonces ira a una subrutina la cual durara 
 280:	41 f0       	breq	.+16     	; 0x292 <un_mSeg>

00000282 <ciclo>:
	;dira 1ms segun lo que se mando por parametro 


	ciclo:

		call delay_general
 282:	0e 94 55 01 	call	0x2aa	; 0x2aa <delay_general>

		sbiw r24, 1 ; 2 
 286:	01 97       	sbiw	r24, 0x01	; 1

		cpi r24, 0x01 ;1
 288:	81 30       	cpi	r24, 0x01	; 1
		brne ciclo ; 2 - 1
 28a:	d9 f7       	brne	.-10     	; 0x282 <ciclo>

		cpi r24,0x01 
 28c:	81 30       	cpi	r24, 0x01	; 1
		breq un_mSeg ; se cumple siempre
 28e:	09 f0       	breq	.+2      	; 0x292 <un_mSeg>

00000290 <final>:


final:
	; agrego un nop porque al final
	
	ret
 290:	08 95       	ret

00000292 <un_mSeg>:
	; jmp -> 3 ciclos 
	
	;usaremos de igual r16-r17-r18


	ldi r16,2 ; 1
 292:	02 e0       	ldi	r16, 0x02	; 2

00000294 <ciclo0_1mS>:
	ciclo0_1mS:
		ldi r17,11 ; 1x
 294:	1b e0       	ldi	r17, 0x0B	; 11
	...

00000298 <ciclo1_1mS>:
		nop ; 1x

		ciclo1_1mS:
			ldi r18, 241 ; 1xy
 298:	21 ef       	ldi	r18, 0xF1	; 241

0000029a <ciclo2_1mS>:

			ciclo2_1mS:
				dec r18 ; 1xyz
 29a:	2a 95       	dec	r18
				brne ciclo2_1mS ; xy(2z-1)
 29c:	f1 f7       	brne	.-4      	; 0x29a <ciclo2_1mS>

			dec r17 ; 1xy
 29e:	1a 95       	dec	r17
			brne ciclo1_1mS ;x(2y-1)
 2a0:	d9 f7       	brne	.-10     	; 0x298 <ciclo1_1mS>
		
		dec r16 ; 1x
 2a2:	0a 95       	dec	r16
		brne ciclo0_1mS ; (2x-1)
 2a4:	b9 f7       	brne	.-18     	; 0x294 <ciclo0_1mS>
	
	jmp final	
 2a6:	0c 94 48 01 	jmp	0x290	; 0x290 <final>

000002aa <delay_general>:

	; este no va a durar exactamento delo 16,000 porque va a contar 
	;en su ciclo las comparaciones fuera y al parecer tan solo tendra 
	;en el ultimo que le faltaria 1 de la comparacion que no es correcta
	
	ldi r16, 115 ; 1
 2aa:	03 e7       	ldi	r16, 0x73	; 115

000002ac <ciclo_0>:

	ciclo_0:
		ldi r17, 1 ; 1x
 2ac:	11 e0       	ldi	r17, 0x01	; 1
	...

000002b0 <ciclo_1>:
		nop

		ciclo_1:

			ldi r18, 44 ; 1xy
 2b0:	2c e2       	ldi	r18, 0x2C	; 44

000002b2 <ciclo_2>:
			ciclo_2:
				dec r18 ; 1zxy
 2b2:	2a 95       	dec	r18
				brne ciclo_2 ; xy(2z-1)
 2b4:	f1 f7       	brne	.-4      	; 0x2b2 <ciclo_2>

			dec r17 ; 1xy
 2b6:	1a 95       	dec	r17
			brne ciclo_1 ;x(2y-1)
 2b8:	d9 f7       	brne	.-10     	; 0x2b0 <ciclo_1>

		dec r16 ; 1x
 2ba:	0a 95       	dec	r16
		brne ciclo_0 ;(2x-1)
 2bc:	b9 f7       	brne	.-18     	; 0x2ac <ciclo_0>
	ret
 2be:	08 95       	ret

000002c0 <_exit>:
 2c0:	f8 94       	cli

000002c2 <__stop_program>:
 2c2:	ff cf       	rjmp	.-2      	; 0x2c2 <__stop_program>
