
practica6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000048  00800200  00000808  0000087c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000808  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .debug_aranges 00000040  00000000  00000000  000008c4  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000ef  00000000  00000000  00000904  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000ae9  00000000  00000000  000009f3  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000032d  00000000  00000000  000014dc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000769  00000000  00000000  00001809  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000000f0  00000000  00000000  00001f74  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000022e  00000000  00000000  00002064  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000773  00000000  00000000  00002292  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000001b0  00000000  00000000  00002a05  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  10:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  14:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  18:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  1c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  20:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  24:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  28:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  2c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  30:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  34:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  38:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  3c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  40:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  44:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  48:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  4c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  50:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  54:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  58:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  5c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  60:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  64:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  68:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  6c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  70:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  74:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  78:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  7c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  80:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  84:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  88:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  8c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  90:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  94:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  98:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  9c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  ac:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  bc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  cc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  dc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  e0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	e8 e0       	ldi	r30, 0x08	; 8
  fc:	f8 e0       	ldi	r31, 0x08	; 8
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a8 34       	cpi	r26, 0x48	; 72
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
 10e:	0e 94 8d 00 	call	0x11a	; 0x11a <main>
 112:	0c 94 02 04 	jmp	0x804	; 0x804 <_exit>

00000116 <__bad_interrupt>:
 116:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000011a <main>:
#include "UART.h"



int main( void )
{
 11a:	cf 92       	push	r12
 11c:	df 92       	push	r13
 11e:	ef 92       	push	r14
 120:	ff 92       	push	r15
 122:	0f 93       	push	r16
 124:	1f 93       	push	r17
 126:	df 93       	push	r29
 128:	cf 93       	push	r28
 12a:	cd b7       	in	r28, 0x3d	; 61
 12c:	de b7       	in	r29, 0x3e	; 62
 12e:	a8 97       	sbiw	r28, 0x28	; 40
 130:	0f b6       	in	r0, 0x3f	; 63
 132:	f8 94       	cli
 134:	de bf       	out	0x3e, r29	; 62
 136:	0f be       	out	0x3f, r0	; 63
 138:	cd bf       	out	0x3d, r28	; 61
    char cad[20];
    char cadUart3[20];
    uint16_t num;


    UART_Ini(0,12345,8,1,2); //comunicacion con teraterm
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	49 e3       	ldi	r20, 0x39	; 57
 13e:	50 e3       	ldi	r21, 0x30	; 48
 140:	60 e0       	ldi	r22, 0x00	; 0
 142:	70 e0       	ldi	r23, 0x00	; 0
 144:	28 e0       	ldi	r18, 0x08	; 8
 146:	01 e0       	ldi	r16, 0x01	; 1
 148:	92 e0       	ldi	r25, 0x02	; 2
 14a:	e9 2e       	mov	r14, r25
 14c:	0e 94 29 01 	call	0x252	; 0x252 <UART_Ini>
    UART_Ini(2,115200,8,0,1);
 150:	82 e0       	ldi	r24, 0x02	; 2
 152:	40 e0       	ldi	r20, 0x00	; 0
 154:	52 ec       	ldi	r21, 0xC2	; 194
 156:	61 e0       	ldi	r22, 0x01	; 1
 158:	70 e0       	ldi	r23, 0x00	; 0
 15a:	28 e0       	ldi	r18, 0x08	; 8
 15c:	00 e0       	ldi	r16, 0x00	; 0
 15e:	ee 24       	eor	r14, r14
 160:	e3 94       	inc	r14
 162:	0e 94 29 01 	call	0x252	; 0x252 <UART_Ini>
    UART_Ini(3,115200,8,0,1);
 166:	83 e0       	ldi	r24, 0x03	; 3
 168:	40 e0       	ldi	r20, 0x00	; 0
 16a:	52 ec       	ldi	r21, 0xC2	; 194
 16c:	61 e0       	ldi	r22, 0x01	; 1
 16e:	70 e0       	ldi	r23, 0x00	; 0
 170:	28 e0       	ldi	r18, 0x08	; 8
 172:	0e 94 29 01 	call	0x252	; 0x252 <UART_Ini>
        UART_setColor(0,YELLOW);
        UART_puts(0,"Introduce un n?mero:"); //terminamos con un caracter nulo, funciona bien puts

        UART_gotoxy(0,22,2);
        UART_setColor(0,GREEN);
        UART_gets(0,cad); //vreremos si este funciona correcto
 176:	7e 01       	movw	r14, r28
 178:	08 94       	sec
 17a:	e1 1c       	adc	r14, r1
 17c:	f1 1c       	adc	r15, r1
// -------------------------------------------
        // Cycle through UART2->UART3
        UART_puts(2,cad);
        UART_puts(2,"\r");
        UART_gets(3,cadUart3);
 17e:	85 e1       	ldi	r24, 0x15	; 21
 180:	c8 2e       	mov	r12, r24
 182:	d1 2c       	mov	r13, r1
 184:	cc 0e       	add	r12, r28
 186:	dd 1e       	adc	r13, r29
    UART_Ini(0,12345,8,1,2); //comunicacion con teraterm
    UART_Ini(2,115200,8,0,1);
    UART_Ini(3,115200,8,0,1);
    while(1)
    {
        UART_getchar(0);//getchar funciona OK
 188:	80 e0       	ldi	r24, 0x00	; 0
 18a:	0e 94 bc 01 	call	0x378	; 0x378 <UART_getchar>
        UART_clrscr(0);
 18e:	80 e0       	ldi	r24, 0x00	; 0
 190:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <UART_clrscr>

        UART_gotoxy(0,2,2);
 194:	80 e0       	ldi	r24, 0x00	; 0
 196:	62 e0       	ldi	r22, 0x02	; 2
 198:	42 e0       	ldi	r20, 0x02	; 2
 19a:	0e 94 ba 02 	call	0x574	; 0x574 <UART_gotoxy>
        UART_setColor(0,YELLOW);
 19e:	80 e0       	ldi	r24, 0x00	; 0
 1a0:	61 e2       	ldi	r22, 0x21	; 33
 1a2:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <UART_setColor>
        UART_puts(0,"Introduce un n?mero:"); //terminamos con un caracter nulo, funciona bien puts
 1a6:	80 e0       	ldi	r24, 0x00	; 0
 1a8:	60 e0       	ldi	r22, 0x00	; 0
 1aa:	72 e0       	ldi	r23, 0x02	; 2
 1ac:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>

        UART_gotoxy(0,22,2);
 1b0:	80 e0       	ldi	r24, 0x00	; 0
 1b2:	66 e1       	ldi	r22, 0x16	; 22
 1b4:	42 e0       	ldi	r20, 0x02	; 2
 1b6:	0e 94 ba 02 	call	0x574	; 0x574 <UART_gotoxy>
        UART_setColor(0,GREEN);
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	60 e2       	ldi	r22, 0x20	; 32
 1be:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <UART_setColor>
        UART_gets(0,cad); //vreremos si este funciona correcto
 1c2:	80 e0       	ldi	r24, 0x00	; 0
 1c4:	b7 01       	movw	r22, r14
 1c6:	0e 94 ca 01 	call	0x394	; 0x394 <UART_gets>
// -------------------------------------------
        // Cycle through UART2->UART3
        UART_puts(2,cad);
 1ca:	82 e0       	ldi	r24, 0x02	; 2
 1cc:	b7 01       	movw	r22, r14
 1ce:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        UART_puts(2,"\r");
 1d2:	82 e0       	ldi	r24, 0x02	; 2
 1d4:	65 e1       	ldi	r22, 0x15	; 21
 1d6:	72 e0       	ldi	r23, 0x02	; 2
 1d8:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        UART_gets(3,cadUart3);
 1dc:	83 e0       	ldi	r24, 0x03	; 3
 1de:	b6 01       	movw	r22, r12
 1e0:	0e 94 ca 01 	call	0x394	; 0x394 <UART_gets>
        UART_gotoxy(0,5,3);
 1e4:	80 e0       	ldi	r24, 0x00	; 0
 1e6:	65 e0       	ldi	r22, 0x05	; 5
 1e8:	43 e0       	ldi	r20, 0x03	; 3
 1ea:	0e 94 ba 02 	call	0x574	; 0x574 <UART_gotoxy>
        UART_puts(0,cadUart3);
 1ee:	80 e0       	ldi	r24, 0x00	; 0
 1f0:	b6 01       	movw	r22, r12
 1f2:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
// -------------------------------------------
        num = atoi(cad);
 1f6:	c7 01       	movw	r24, r14
 1f8:	0e 94 b6 03 	call	0x76c	; 0x76c <atoi>
 1fc:	8c 01       	movw	r16, r24
        itoa(num,cad,16);
 1fe:	b7 01       	movw	r22, r14
 200:	40 e1       	ldi	r20, 0x10	; 16
 202:	0e 94 2a 03 	call	0x654	; 0x654 <itoa>

        UART_gotoxy(0,5,4);
 206:	80 e0       	ldi	r24, 0x00	; 0
 208:	65 e0       	ldi	r22, 0x05	; 5
 20a:	44 e0       	ldi	r20, 0x04	; 4
 20c:	0e 94 ba 02 	call	0x574	; 0x574 <UART_gotoxy>
        UART_setColor(0,BLUE);
 210:	80 e0       	ldi	r24, 0x00	; 0
 212:	62 e2       	ldi	r22, 0x22	; 34
 214:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <UART_setColor>
        UART_puts(0,"Hex: ");
 218:	80 e0       	ldi	r24, 0x00	; 0
 21a:	67 e1       	ldi	r22, 0x17	; 23
 21c:	72 e0       	ldi	r23, 0x02	; 2
 21e:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        UART_puts(0,cad);
 222:	80 e0       	ldi	r24, 0x00	; 0
 224:	b7 01       	movw	r22, r14
 226:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        itoa(num,cad,2);
 22a:	c8 01       	movw	r24, r16
 22c:	b7 01       	movw	r22, r14
 22e:	42 e0       	ldi	r20, 0x02	; 2
 230:	0e 94 2a 03 	call	0x654	; 0x654 <itoa>

        UART_gotoxy(0,5,5);
 234:	80 e0       	ldi	r24, 0x00	; 0
 236:	65 e0       	ldi	r22, 0x05	; 5
 238:	45 e0       	ldi	r20, 0x05	; 5
 23a:	0e 94 ba 02 	call	0x574	; 0x574 <UART_gotoxy>
        UART_puts(0,"Bin: ");
 23e:	80 e0       	ldi	r24, 0x00	; 0
 240:	6d e1       	ldi	r22, 0x1D	; 29
 242:	72 e0       	ldi	r23, 0x02	; 2
 244:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        UART_puts(0,cad);
 248:	80 e0       	ldi	r24, 0x00	; 0
 24a:	b7 01       	movw	r22, r14
 24c:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
 250:	9b cf       	rjmp	.-202    	; 0x188 <main+0x6e>

00000252 <UART_Ini>:

};



UART_Ini(uint8_t com, uint32_t baudrate, uint8_t size, uint8_t parity, uint8_t stop){
 252:	af 92       	push	r10
 254:	bf 92       	push	r11
 256:	cf 92       	push	r12
 258:	df 92       	push	r13
 25a:	ef 92       	push	r14
 25c:	0f 93       	push	r16
 25e:	cf 93       	push	r28
 260:	df 93       	push	r29
 262:	5a 01       	movw	r10, r20
 264:	6b 01       	movw	r12, r22
 266:	92 2f       	mov	r25, r18
 268:	2e 2d       	mov	r18, r14

    UART_reg_t *myUART = UART_offset[com]; // eligo a mi UART
 26a:	e8 2f       	mov	r30, r24
 26c:	f0 e0       	ldi	r31, 0x00	; 0
 26e:	ee 0f       	add	r30, r30
 270:	ff 1f       	adc	r31, r31
 272:	e0 5c       	subi	r30, 0xC0	; 192
 274:	fd 4f       	sbci	r31, 0xFD	; 253
 276:	c0 81       	ld	r28, Z
 278:	d1 81       	ldd	r29, Z+1	; 0x01

    myUART->UCSRB = (1 << TXEN0) | (1 << RXEN0); // Habilita TX y RX para UART0
 27a:	88 e1       	ldi	r24, 0x18	; 24
 27c:	89 83       	std	Y+1, r24	; 0x01
    //establecer las paridades
	//uint8_t parity_mode= (parity == 1) ? 2 : 3;  // 2: Paridad par, 3: Paridad impar

    uint8_t parity_mode=0;

    switch(parity){
 27e:	01 30       	cpi	r16, 0x01	; 1
 280:	21 f0       	breq	.+8      	; 0x28a <UART_Ini+0x38>
 282:	02 30       	cpi	r16, 0x02	; 2
 284:	21 f4       	brne	.+8      	; 0x28e <UART_Ini+0x3c>
 286:	82 e0       	ldi	r24, 0x02	; 2
 288:	03 c0       	rjmp	.+6      	; 0x290 <UART_Ini+0x3e>
 28a:	83 e0       	ldi	r24, 0x03	; 3
 28c:	01 c0       	rjmp	.+2      	; 0x290 <UART_Ini+0x3e>
 28e:	80 e0       	ldi	r24, 0x00	; 0
    //me manda sde de 1 o 2 por lo que ocn este ternearo decivo si es 1 sera 1 bit de parada 0
    //pero si es otro valor seran 2 bits de parada

    uint8_t stop_mode= (stop == 1)? 0:1;

    myUART->UCSRC = (parity_mode << UPM00) | (stop_mode <<USBS0);
 290:	e8 2f       	mov	r30, r24
 292:	f0 e0       	ldi	r31, 0x00	; 0
 294:	54 e0       	ldi	r21, 0x04	; 4
 296:	ee 0f       	add	r30, r30
 298:	ff 1f       	adc	r31, r31
 29a:	5a 95       	dec	r21
 29c:	e1 f7       	brne	.-8      	; 0x296 <UART_Ini+0x44>
 29e:	60 e0       	ldi	r22, 0x00	; 0
 2a0:	70 e0       	ldi	r23, 0x00	; 0
 2a2:	21 30       	cpi	r18, 0x01	; 1
 2a4:	11 f0       	breq	.+4      	; 0x2aa <UART_Ini+0x58>
 2a6:	61 e0       	ldi	r22, 0x01	; 1
 2a8:	70 e0       	ldi	r23, 0x00	; 0
 2aa:	43 e0       	ldi	r20, 0x03	; 3
 2ac:	66 0f       	add	r22, r22
 2ae:	77 1f       	adc	r23, r23
 2b0:	4a 95       	dec	r20
 2b2:	e1 f7       	brne	.-8      	; 0x2ac <UART_Ini+0x5a>
 2b4:	8e 2f       	mov	r24, r30
 2b6:	86 2b       	or	r24, r22
 2b8:	8a 83       	std	Y+2, r24	; 0x02

		myUART->UCSRC = 3 << UCSZ00;
		myUART->UCSRB = 1<< UCSZ02; //habilitamos los 9 bits
	}*/

	if (size == 9) {
 2ba:	99 30       	cpi	r25, 0x09	; 9
 2bc:	39 f4       	brne	.+14     	; 0x2cc <UART_Ini+0x7a>
        myUART->UCSRC |= (3 << UCSZ00); // UCSZ01:UCSZ00 = 0b11
 2be:	8a 81       	ldd	r24, Y+2	; 0x02
 2c0:	86 60       	ori	r24, 0x06	; 6
 2c2:	8a 83       	std	Y+2, r24	; 0x02
        myUART->UCSRB |= (1 << UCSZ02); // Habilitar bit 9
 2c4:	89 81       	ldd	r24, Y+1	; 0x01
 2c6:	84 60       	ori	r24, 0x04	; 4
 2c8:	89 83       	std	Y+1, r24	; 0x01
 2ca:	08 c0       	rjmp	.+16     	; 0x2dc <UART_Ini+0x8a>
    } else
     {
        myUART->UCSRC |= ((size - 5) << UCSZ00); // Ej: 8 bits ? 3 << UCSZ00
 2cc:	2a 81       	ldd	r18, Y+2	; 0x02
 2ce:	89 2f       	mov	r24, r25
 2d0:	90 e0       	ldi	r25, 0x00	; 0
 2d2:	05 97       	sbiw	r24, 0x05	; 5
 2d4:	88 0f       	add	r24, r24
 2d6:	99 1f       	adc	r25, r25
 2d8:	28 2b       	or	r18, r24
 2da:	2a 83       	std	Y+2, r18	; 0x02
    }

    uint16_t v_UBRR = (FOSC / (16 * baudrate)) - 1 ;
 2dc:	84 e0       	ldi	r24, 0x04	; 4
 2de:	aa 0c       	add	r10, r10
 2e0:	bb 1c       	adc	r11, r11
 2e2:	cc 1c       	adc	r12, r12
 2e4:	dd 1c       	adc	r13, r13
 2e6:	8a 95       	dec	r24
 2e8:	d1 f7       	brne	.-12     	; 0x2de <UART_Ini+0x8c>
 2ea:	60 e0       	ldi	r22, 0x00	; 0
 2ec:	74 e2       	ldi	r23, 0x24	; 36
 2ee:	84 ef       	ldi	r24, 0xF4	; 244
 2f0:	90 e0       	ldi	r25, 0x00	; 0
 2f2:	a6 01       	movw	r20, r12
 2f4:	95 01       	movw	r18, r10
 2f6:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <__udivmodsi4>
 2fa:	21 50       	subi	r18, 0x01	; 1
 2fc:	30 40       	sbci	r19, 0x00	; 0
    myUART->UBRR = v_UBRR;
 2fe:	3d 83       	std	Y+5, r19	; 0x05
 300:	2c 83       	std	Y+4, r18	; 0x04
}
 302:	df 91       	pop	r29
 304:	cf 91       	pop	r28
 306:	0f 91       	pop	r16
 308:	ef 90       	pop	r14
 30a:	df 90       	pop	r13
 30c:	cf 90       	pop	r12
 30e:	bf 90       	pop	r11
 310:	af 90       	pop	r10
 312:	08 95       	ret

00000314 <UART_puts>:
*/


//este haria lo mismo de putchar la unica deiferente es que este estara
//recorriendo la cadena que se quiere imprimir
void UART_puts(uint8_t com, char *str){
 314:	cf 93       	push	r28
 316:	df 93       	push	r29
 318:	eb 01       	movw	r28, r22
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 31a:	e8 2f       	mov	r30, r24
 31c:	f0 e0       	ldi	r31, 0x00	; 0
 31e:	ee 0f       	add	r30, r30
 320:	ff 1f       	adc	r31, r31
 322:	e0 5c       	subi	r30, 0xC0	; 192
 324:	fd 4f       	sbci	r31, 0xFD	; 253
 326:	08 c0       	rjmp	.+16     	; 0x338 <UART_puts+0x24>
 328:	a0 81       	ld	r26, Z
 32a:	b1 81       	ldd	r27, Z+1	; 0x01
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 32c:	8c 91       	ld	r24, X
 32e:	85 ff       	sbrs	r24, 5
 330:	fd cf       	rjmp	.-6      	; 0x32c <UART_puts+0x18>
void UART_puts(uint8_t com, char *str){

	//TXn trasmitir el contenido
	while(*str!= '\0'){
		//mientras haya contenido en el apuntador, que sea diferente a NULL
		UART_putchar(com,*str++);
 332:	21 96       	adiw	r28, 0x01	; 1

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 334:	16 96       	adiw	r26, 0x06	; 6
 336:	9c 93       	st	X, r25
//este haria lo mismo de putchar la unica deiferente es que este estara
//recorriendo la cadena que se quiere imprimir
void UART_puts(uint8_t com, char *str){

	//TXn trasmitir el contenido
	while(*str!= '\0'){
 338:	98 81       	ld	r25, Y
 33a:	99 23       	and	r25, r25
 33c:	a9 f7       	brne	.-22     	; 0x328 <UART_puts+0x14>
		//mientras haya contenido en el apuntador, que sea diferente a NULL
		UART_putchar(com,*str++);
	}
}
 33e:	df 91       	pop	r29
 340:	cf 91       	pop	r28
 342:	08 95       	ret

00000344 <UART_putchar>:
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 344:	e8 2f       	mov	r30, r24
 346:	f0 e0       	ldi	r31, 0x00	; 0
 348:	ee 0f       	add	r30, r30
 34a:	ff 1f       	adc	r31, r31
 34c:	e0 5c       	subi	r30, 0xC0	; 192
 34e:	fd 4f       	sbci	r31, 0xFD	; 253
 350:	01 90       	ld	r0, Z+
 352:	f0 81       	ld	r31, Z
 354:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 356:	80 81       	ld	r24, Z
 358:	85 ff       	sbrs	r24, 5
 35a:	fd cf       	rjmp	.-6      	; 0x356 <UART_putchar+0x12>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 35c:	66 83       	std	Z+6, r22	; 0x06
}
 35e:	08 95       	ret

00000360 <UART_available>:
uint8_t UART_available(uint8_t com){

	//RXC0 sta en 1 cuando hay un dato sin leer en RXC
	//y esta en 0 cunado este no tiene nada

	UART_reg_t *myUART = UART_offset[com];
 360:	e8 2f       	mov	r30, r24
 362:	f0 e0       	ldi	r31, 0x00	; 0
 364:	ee 0f       	add	r30, r30
 366:	ff 1f       	adc	r31, r31
 368:	e0 5c       	subi	r30, 0xC0	; 192
 36a:	fd 4f       	sbci	r31, 0xFD	; 253
 36c:	01 90       	ld	r0, Z+
 36e:	f0 81       	ld	r31, Z
 370:	e0 2d       	mov	r30, r0

	return (myUART->UCSRA & (1 << RXC0)) ; // Hay dato disponible
 372:	80 81       	ld	r24, Z
	//creo que va a asi pero si hay errores podemos invertirlo
}
 374:	80 78       	andi	r24, 0x80	; 128
 376:	08 95       	ret

00000378 <UART_getchar>:
	return myUART->UDR;
}*/


char UART_getchar(uint8_t com) {
    UART_reg_t *myUART = UART_offset[com];
 378:	e8 2f       	mov	r30, r24
 37a:	f0 e0       	ldi	r31, 0x00	; 0
 37c:	ee 0f       	add	r30, r30
 37e:	ff 1f       	adc	r31, r31
 380:	e0 5c       	subi	r30, 0xC0	; 192
 382:	fd 4f       	sbci	r31, 0xFD	; 253
 384:	01 90       	ld	r0, Z+
 386:	f0 81       	ld	r31, Z
 388:	e0 2d       	mov	r30, r0
    while (!(myUART->UCSRA & (1 << RXC0))); // Espera dato
 38a:	80 81       	ld	r24, Z
 38c:	87 ff       	sbrs	r24, 7
 38e:	fd cf       	rjmp	.-6      	; 0x38a <UART_getchar+0x12>
    return myUART->UDR;
 390:	86 81       	ldd	r24, Z+6	; 0x06
}
 392:	08 95       	ret

00000394 <UART_gets>:


void UART_gets(uint8_t com, char *str){
 394:	cf 93       	push	r28
 396:	df 93       	push	r29
 398:	9b 01       	movw	r18, r22
 39a:	40 e0       	ldi	r20, 0x00	; 0
 39c:	60 e0       	ldi	r22, 0x00	; 0
	return myUART->UDR;
}*/


char UART_getchar(uint8_t com) {
    UART_reg_t *myUART = UART_offset[com];
 39e:	c8 2f       	mov	r28, r24
 3a0:	d0 e0       	ldi	r29, 0x00	; 0
 3a2:	de 01       	movw	r26, r28
 3a4:	aa 0f       	add	r26, r26
 3a6:	bb 1f       	adc	r27, r27
 3a8:	a0 5c       	subi	r26, 0xC0	; 192
 3aa:	bd 4f       	sbci	r27, 0xFD	; 253

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 3ac:	58 e0       	ldi	r21, 0x08	; 8
    while (!(myUART->UCSRA & (1 << RXC0))); // Espera dato
    return myUART->UDR;
}


void UART_gets(uint8_t com, char *str){
 3ae:	70 e2       	ldi	r23, 0x20	; 32
 3b0:	01 c0       	rjmp	.+2      	; 0x3b4 <UART_gets+0x20>
 3b2:	61 e0       	ldi	r22, 0x01	; 1
	return myUART->UDR;
}*/


char UART_getchar(uint8_t com) {
    UART_reg_t *myUART = UART_offset[com];
 3b4:	ed 91       	ld	r30, X+
 3b6:	fc 91       	ld	r31, X
 3b8:	11 97       	sbiw	r26, 0x01	; 1
    while (!(myUART->UCSRA & (1 << RXC0))); // Espera dato
 3ba:	80 81       	ld	r24, Z
 3bc:	87 ff       	sbrs	r24, 7
 3be:	fd cf       	rjmp	.-6      	; 0x3ba <UART_gets+0x26>
    return myUART->UDR;
 3c0:	96 81       	ldd	r25, Z+6	; 0x06
		-cuando se limpia la pantalla

		*/
		//verificamos si se quiere borrar que en efecto haya algo que borrar

		if(dot_flag){
 3c2:	66 23       	and	r22, r22
 3c4:	f9 f0       	breq	.+62     	; 0x404 <UART_gets+0x70>

             if (c == '\r' || c == '\n') {
 3c6:	9d 30       	cpi	r25, 0x0D	; 13
 3c8:	11 f0       	breq	.+4      	; 0x3ce <UART_gets+0x3a>
 3ca:	9a 30       	cpi	r25, 0x0A	; 10
 3cc:	91 f7       	brne	.-28     	; 0x3b2 <UART_gets+0x1e>
                str[i] = '\0';
 3ce:	24 0f       	add	r18, r20
 3d0:	31 1d       	adc	r19, r1
 3d2:	f9 01       	movw	r30, r18
 3d4:	10 82       	st	Z, r1
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 3d6:	fe 01       	movw	r30, r28
 3d8:	ee 0f       	add	r30, r30
 3da:	ff 1f       	adc	r31, r31
 3dc:	e0 5c       	subi	r30, 0xC0	; 192
 3de:	fd 4f       	sbci	r31, 0xFD	; 253
 3e0:	01 90       	ld	r0, Z+
 3e2:	f0 81       	ld	r31, Z
 3e4:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 3e6:	80 81       	ld	r24, Z
 3e8:	85 ff       	sbrs	r24, 5
 3ea:	fd cf       	rjmp	.-6      	; 0x3e6 <UART_gets+0x52>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 3ec:	8d e0       	ldi	r24, 0x0D	; 13
 3ee:	86 83       	std	Z+6, r24	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 3f0:	cc 0f       	add	r28, r28
 3f2:	dd 1f       	adc	r29, r29
 3f4:	c0 5c       	subi	r28, 0xC0	; 192
 3f6:	dd 4f       	sbci	r29, 0xFD	; 253
 3f8:	e8 81       	ld	r30, Y
 3fa:	f9 81       	ldd	r31, Y+1	; 0x01
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 3fc:	80 81       	ld	r24, Z
 3fe:	85 ff       	sbrs	r24, 5
 400:	fd cf       	rjmp	.-6      	; 0x3fc <UART_gets+0x68>
 402:	43 c0       	rjmp	.+134    	; 0x48a <UART_gets+0xf6>
            continue;
		}



		if(c=='\b'){
 404:	98 30       	cpi	r25, 0x08	; 8
 406:	e1 f4       	brne	.+56     	; 0x440 <UART_gets+0xac>
			if(i>0){
 408:	44 23       	and	r20, r20
 40a:	a1 f2       	breq	.-88     	; 0x3b4 <UART_gets+0x20>

				str[--i] = '\0'; //sustitumos el utlimo caracter con el nulo
 40c:	41 50       	subi	r20, 0x01	; 1
 40e:	f9 01       	movw	r30, r18
 410:	e4 0f       	add	r30, r20
 412:	f1 1d       	adc	r31, r1
 414:	10 82       	st	Z, r1
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 416:	ed 91       	ld	r30, X+
 418:	fc 91       	ld	r31, X
 41a:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 41c:	80 81       	ld	r24, Z
 41e:	85 ff       	sbrs	r24, 5
 420:	fd cf       	rjmp	.-6      	; 0x41c <UART_gets+0x88>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 422:	56 83       	std	Z+6, r21	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 424:	ed 91       	ld	r30, X+
 426:	fc 91       	ld	r31, X
 428:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 42a:	80 81       	ld	r24, Z
 42c:	85 ff       	sbrs	r24, 5
 42e:	fd cf       	rjmp	.-6      	; 0x42a <UART_gets+0x96>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 430:	76 83       	std	Z+6, r23	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 432:	ed 91       	ld	r30, X+
 434:	fc 91       	ld	r31, X
 436:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 438:	80 81       	ld	r24, Z
 43a:	85 ff       	sbrs	r24, 5
 43c:	fd cf       	rjmp	.-6      	; 0x438 <UART_gets+0xa4>
 43e:	4a c0       	rjmp	.+148    	; 0x4d4 <UART_gets+0x140>
			}

			continue; // si no hay nada que borrar o si hay algoq ue borrar sigue con el ciclo
		}

		 if (c == '.') {
 440:	9e 32       	cpi	r25, 0x2E	; 46
 442:	09 f4       	brne	.+2      	; 0x446 <UART_gets+0xb2>
 444:	b6 cf       	rjmp	.-148    	; 0x3b2 <UART_gets+0x1e>
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 446:	80 81       	ld	r24, Z
 448:	85 ff       	sbrs	r24, 5
 44a:	fd cf       	rjmp	.-6      	; 0x446 <UART_gets+0xb2>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 44c:	96 83       	std	Z+6, r25	; 0x06
            continue; // No muestra el punto
        }

		UART_putchar(com,c);

		if(c == '\r' || c== '\n'){
 44e:	9d 30       	cpi	r25, 0x0D	; 13
 450:	11 f0       	breq	.+4      	; 0x456 <UART_gets+0xc2>
 452:	9a 30       	cpi	r25, 0x0A	; 10
 454:	f9 f4       	brne	.+62     	; 0x494 <UART_gets+0x100>
		//retorno de carro o salto de linea lo que quiere decir que se terminao de escribir el
		//texto actual.

			str[i]='\0'; //caracter nulo denotando que la
 456:	24 0f       	add	r18, r20
 458:	31 1d       	adc	r19, r1
 45a:	f9 01       	movw	r30, r18
 45c:	10 82       	st	Z, r1
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 45e:	fe 01       	movw	r30, r28
 460:	ee 0f       	add	r30, r30
 462:	ff 1f       	adc	r31, r31
 464:	e0 5c       	subi	r30, 0xC0	; 192
 466:	fd 4f       	sbci	r31, 0xFD	; 253
 468:	01 90       	ld	r0, Z+
 46a:	f0 81       	ld	r31, Z
 46c:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 46e:	80 81       	ld	r24, Z
 470:	85 ff       	sbrs	r24, 5
 472:	fd cf       	rjmp	.-6      	; 0x46e <UART_gets+0xda>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 474:	8d e0       	ldi	r24, 0x0D	; 13
 476:	86 83       	std	Z+6, r24	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 478:	cc 0f       	add	r28, r28
 47a:	dd 1f       	adc	r29, r29
 47c:	c0 5c       	subi	r28, 0xC0	; 192
 47e:	dd 4f       	sbci	r29, 0xFD	; 253
 480:	e8 81       	ld	r30, Y
 482:	f9 81       	ldd	r31, Y+1	; 0x01
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 484:	80 81       	ld	r24, Z
 486:	85 ff       	sbrs	r24, 5
 488:	fd cf       	rjmp	.-6      	; 0x484 <UART_gets+0xf0>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 48a:	8a e0       	ldi	r24, 0x0A	; 10
 48c:	86 83       	std	Z+6, r24	; 0x06
			UART_putchar(com, ' ');
			UART_putchar(com,'\b');
        }
	}

}
 48e:	df 91       	pop	r29
 490:	cf 91       	pop	r28
 492:	08 95       	ret
 494:	e4 2f       	mov	r30, r20
 496:	f0 e0       	ldi	r31, 0x00	; 0
			UART_putchar(com,'\n'); //salto de linea
			break; //rompesmos el ciclo y a esperar que se vuelva a escribir algo
		}
		//para 20 caracteres, si no lo regresamos a 127

		if(i<19){
 498:	43 31       	cpi	r20, 0x13	; 19
 49a:	28 f4       	brcc	.+10     	; 0x4a6 <UART_gets+0x112>

			str[i++]= c;
 49c:	e2 0f       	add	r30, r18
 49e:	f3 1f       	adc	r31, r19
 4a0:	90 83       	st	Z, r25
 4a2:	4f 5f       	subi	r20, 0xFF	; 255
 4a4:	87 cf       	rjmp	.-242    	; 0x3b4 <UART_gets+0x20>
				esta en el indece maximo +1 entonces lo que hace es como el borraro de ese sigueitne
				caractere por lo que parece que no se esta capturando pero lo que hace es que se esta borrando
				constantement lo que se captrua despues
			*/

			str[i] = '\0'; //sustitumos el utlimo caracter con el nulo
 4a6:	e2 0f       	add	r30, r18
 4a8:	f3 1f       	adc	r31, r19
 4aa:	10 82       	st	Z, r1
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 4ac:	ed 91       	ld	r30, X+
 4ae:	fc 91       	ld	r31, X
 4b0:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 4b2:	80 81       	ld	r24, Z
 4b4:	85 ff       	sbrs	r24, 5
 4b6:	fd cf       	rjmp	.-6      	; 0x4b2 <UART_gets+0x11e>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 4b8:	56 83       	std	Z+6, r21	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 4ba:	ed 91       	ld	r30, X+
 4bc:	fc 91       	ld	r31, X
 4be:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 4c0:	80 81       	ld	r24, Z
 4c2:	85 ff       	sbrs	r24, 5
 4c4:	fd cf       	rjmp	.-6      	; 0x4c0 <UART_gets+0x12c>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 4c6:	76 83       	std	Z+6, r23	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 4c8:	ed 91       	ld	r30, X+
 4ca:	fc 91       	ld	r31, X
 4cc:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 4ce:	80 81       	ld	r24, Z
 4d0:	85 ff       	sbrs	r24, 5
 4d2:	fd cf       	rjmp	.-6      	; 0x4ce <UART_gets+0x13a>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 4d4:	56 83       	std	Z+6, r21	; 0x06
 4d6:	6e cf       	rjmp	.-292    	; 0x3b4 <UART_gets+0x20>

000004d8 <UART_clrscr>:

}


// Escape sequences
UART_clrscr( uint8_t com ){
 4d8:	1f 93       	push	r17
 4da:	18 2f       	mov	r17, r24
        que con ESC[2J se borra toda la pantalla

        lo mismo para con posicionar al inicio de la termianl
        sin parametros H se estbalce en la fila1 - columna1
    */
    UART_puts(com,"\x1B[2J"); //borra toda la pantalla
 4dc:	63 e2       	ldi	r22, 0x23	; 35
 4de:	72 e0       	ldi	r23, 0x02	; 2
 4e0:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
    UART_puts(com,"\x1B[H"); // poen el curso al incio fila 1, columna 1
 4e4:	81 2f       	mov	r24, r17
 4e6:	68 e2       	ldi	r22, 0x28	; 40
 4e8:	72 e0       	ldi	r23, 0x02	; 2
 4ea:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>


}
 4ee:	1f 91       	pop	r17
 4f0:	08 95       	ret

000004f2 <UART_putnum>:


void UART_putnum(uint8_t com, uint8_t num){
 4f2:	38 2f       	mov	r19, r24
 4f4:	26 2f       	mov	r18, r22

    if(num >= 100){
 4f6:	64 36       	cpi	r22, 0x64	; 100
 4f8:	b0 f0       	brcs	.+44     	; 0x526 <UART_putnum+0x34>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 4fa:	e8 2f       	mov	r30, r24
 4fc:	f0 e0       	ldi	r31, 0x00	; 0
 4fe:	ee 0f       	add	r30, r30
 500:	ff 1f       	adc	r31, r31
 502:	e0 5c       	subi	r30, 0xC0	; 192
 504:	fd 4f       	sbci	r31, 0xFD	; 253
 506:	01 90       	ld	r0, Z+
 508:	f0 81       	ld	r31, Z
 50a:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 50c:	80 81       	ld	r24, Z
 50e:	85 ff       	sbrs	r24, 5
 510:	fd cf       	rjmp	.-6      	; 0x50c <UART_putnum+0x1a>


void UART_putnum(uint8_t com, uint8_t num){

    if(num >= 100){
        UART_putchar(com, '0'+(num/100));
 512:	82 2f       	mov	r24, r18
 514:	64 e6       	ldi	r22, 0x64	; 100
 516:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <__udivmodqi4>
 51a:	80 5d       	subi	r24, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 51c:	86 83       	std	Z+6, r24	; 0x06

void UART_putnum(uint8_t com, uint8_t num){

    if(num >= 100){
        UART_putchar(com, '0'+(num/100));
        num%=100;
 51e:	82 2f       	mov	r24, r18
 520:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <__udivmodqi4>
 524:	29 2f       	mov	r18, r25
    }
    if(num>=10){
 526:	2a 30       	cpi	r18, 0x0A	; 10
 528:	b0 f0       	brcs	.+44     	; 0x556 <UART_putnum+0x64>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 52a:	e3 2f       	mov	r30, r19
 52c:	f0 e0       	ldi	r31, 0x00	; 0
 52e:	ee 0f       	add	r30, r30
 530:	ff 1f       	adc	r31, r31
 532:	e0 5c       	subi	r30, 0xC0	; 192
 534:	fd 4f       	sbci	r31, 0xFD	; 253
 536:	01 90       	ld	r0, Z+
 538:	f0 81       	ld	r31, Z
 53a:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 53c:	80 81       	ld	r24, Z
 53e:	85 ff       	sbrs	r24, 5
 540:	fd cf       	rjmp	.-6      	; 0x53c <UART_putnum+0x4a>
    if(num >= 100){
        UART_putchar(com, '0'+(num/100));
        num%=100;
    }
    if(num>=10){
        UART_putchar(com, '0'+(num/10));
 542:	82 2f       	mov	r24, r18
 544:	6a e0       	ldi	r22, 0x0A	; 10
 546:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <__udivmodqi4>
 54a:	80 5d       	subi	r24, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 54c:	86 83       	std	Z+6, r24	; 0x06
        UART_putchar(com, '0'+(num/100));
        num%=100;
    }
    if(num>=10){
        UART_putchar(com, '0'+(num/10));
        num%=10;
 54e:	82 2f       	mov	r24, r18
 550:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <__udivmodqi4>
 554:	29 2f       	mov	r18, r25
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 556:	e3 2f       	mov	r30, r19
 558:	f0 e0       	ldi	r31, 0x00	; 0
 55a:	ee 0f       	add	r30, r30
 55c:	ff 1f       	adc	r31, r31
 55e:	e0 5c       	subi	r30, 0xC0	; 192
 560:	fd 4f       	sbci	r31, 0xFD	; 253
 562:	01 90       	ld	r0, Z+
 564:	f0 81       	ld	r31, Z
 566:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 568:	80 81       	ld	r24, Z
 56a:	85 ff       	sbrs	r24, 5
 56c:	fd cf       	rjmp	.-6      	; 0x568 <UART_putnum+0x76>
    if(num>=10){
        UART_putchar(com, '0'+(num/10));
        num%=10;
    }

    UART_putchar(com,'0'+num);
 56e:	20 5d       	subi	r18, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 570:	26 83       	std	Z+6, r18	; 0x06
        num%=10;
    }

    UART_putchar(com,'0'+num);

}
 572:	08 95       	ret

00000574 <UART_gotoxy>:


UART_gotoxy(uint8_t com, uint8_t x, uint8_t y){
 574:	ff 92       	push	r15
 576:	0f 93       	push	r16
 578:	1f 93       	push	r17
 57a:	cf 93       	push	r28
 57c:	df 93       	push	r29
 57e:	08 2f       	mov	r16, r24
 580:	f6 2e       	mov	r15, r22
 582:	14 2f       	mov	r17, r20

    UART_puts(com,"\x1B["); //inicio de la secuencia de esapce
 584:	6c e2       	ldi	r22, 0x2C	; 44
 586:	72 e0       	ldi	r23, 0x02	; 2
 588:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>

    UART_putnum(com,y+1); //convertir a caracter
 58c:	1f 5f       	subi	r17, 0xFF	; 255
 58e:	80 2f       	mov	r24, r16
 590:	61 2f       	mov	r22, r17
 592:	0e 94 79 02 	call	0x4f2	; 0x4f2 <UART_putnum>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 596:	c0 2f       	mov	r28, r16
 598:	d0 e0       	ldi	r29, 0x00	; 0
 59a:	fe 01       	movw	r30, r28
 59c:	ee 0f       	add	r30, r30
 59e:	ff 1f       	adc	r31, r31
 5a0:	e0 5c       	subi	r30, 0xC0	; 192
 5a2:	fd 4f       	sbci	r31, 0xFD	; 253
 5a4:	01 90       	ld	r0, Z+
 5a6:	f0 81       	ld	r31, Z
 5a8:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 5aa:	80 81       	ld	r24, Z
 5ac:	85 ff       	sbrs	r24, 5
 5ae:	fd cf       	rjmp	.-6      	; 0x5aa <UART_gotoxy+0x36>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 5b0:	8b e3       	ldi	r24, 0x3B	; 59
 5b2:	86 83       	std	Z+6, r24	; 0x06

    UART_puts(com,"\x1B["); //inicio de la secuencia de esapce

    UART_putnum(com,y+1); //convertir a caracter
    UART_putchar(com,';');
    UART_putnum(com,x+1);
 5b4:	f3 94       	inc	r15
 5b6:	80 2f       	mov	r24, r16
 5b8:	6f 2d       	mov	r22, r15
 5ba:	0e 94 79 02 	call	0x4f2	; 0x4f2 <UART_putnum>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 5be:	cc 0f       	add	r28, r28
 5c0:	dd 1f       	adc	r29, r29
 5c2:	c0 5c       	subi	r28, 0xC0	; 192
 5c4:	dd 4f       	sbci	r29, 0xFD	; 253
 5c6:	e8 81       	ld	r30, Y
 5c8:	f9 81       	ldd	r31, Y+1	; 0x01
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 5ca:	80 81       	ld	r24, Z
 5cc:	85 ff       	sbrs	r24, 5
 5ce:	fd cf       	rjmp	.-6      	; 0x5ca <UART_gotoxy+0x56>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 5d0:	88 e4       	ldi	r24, 0x48	; 72
 5d2:	86 83       	std	Z+6, r24	; 0x06
    UART_putnum(com,y+1); //convertir a caracter
    UART_putchar(com,';');
    UART_putnum(com,x+1);
    UART_putchar(com,'H'); //final de la secuencia

}
 5d4:	df 91       	pop	r29
 5d6:	cf 91       	pop	r28
 5d8:	1f 91       	pop	r17
 5da:	0f 91       	pop	r16
 5dc:	ff 90       	pop	r15
 5de:	08 95       	ret

000005e0 <UART_setColor>:





UART_setColor(uint8_t com, uint8_t color){
 5e0:	0f 93       	push	r16
 5e2:	1f 93       	push	r17
 5e4:	18 2f       	mov	r17, r24
 5e6:	06 2f       	mov	r16, r22


    UART_puts(com,"\x1B["); //incio del comando espace
 5e8:	6c e2       	ldi	r22, 0x2C	; 44
 5ea:	72 e0       	ldi	r23, 0x02	; 2
 5ec:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 5f0:	a1 2f       	mov	r26, r17
 5f2:	b0 e0       	ldi	r27, 0x00	; 0
 5f4:	fd 01       	movw	r30, r26
 5f6:	ee 0f       	add	r30, r30
 5f8:	ff 1f       	adc	r31, r31
 5fa:	e0 5c       	subi	r30, 0xC0	; 192
 5fc:	fd 4f       	sbci	r31, 0xFD	; 253
 5fe:	01 90       	ld	r0, Z+
 600:	f0 81       	ld	r31, Z
 602:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 604:	80 81       	ld	r24, Z
 606:	85 ff       	sbrs	r24, 5
 608:	fd cf       	rjmp	.-6      	; 0x604 <UART_setColor+0x24>

UART_setColor(uint8_t com, uint8_t color){


    UART_puts(com,"\x1B["); //incio del comando espace
    UART_putchar(com, '0'+(color/10));
 60a:	80 2f       	mov	r24, r16
 60c:	6a e0       	ldi	r22, 0x0A	; 10
 60e:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <__udivmodqi4>
 612:	80 5d       	subi	r24, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 614:	86 83       	std	Z+6, r24	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 616:	fd 01       	movw	r30, r26
 618:	ee 0f       	add	r30, r30
 61a:	ff 1f       	adc	r31, r31
 61c:	e0 5c       	subi	r30, 0xC0	; 192
 61e:	fd 4f       	sbci	r31, 0xFD	; 253
 620:	01 90       	ld	r0, Z+
 622:	f0 81       	ld	r31, Z
 624:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 626:	80 81       	ld	r24, Z
 628:	85 ff       	sbrs	r24, 5
 62a:	fd cf       	rjmp	.-6      	; 0x626 <UART_setColor+0x46>
UART_setColor(uint8_t com, uint8_t color){


    UART_puts(com,"\x1B["); //incio del comando espace
    UART_putchar(com, '0'+(color/10));
    UART_putchar(com,'0'+(color%10));
 62c:	80 2f       	mov	r24, r16
 62e:	6a e0       	ldi	r22, 0x0A	; 10
 630:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <__udivmodqi4>
 634:	90 5d       	subi	r25, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 636:	96 83       	std	Z+6, r25	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 638:	aa 0f       	add	r26, r26
 63a:	bb 1f       	adc	r27, r27
 63c:	a0 5c       	subi	r26, 0xC0	; 192
 63e:	bd 4f       	sbci	r27, 0xFD	; 253
 640:	ed 91       	ld	r30, X+
 642:	fc 91       	ld	r31, X
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 644:	80 81       	ld	r24, Z
 646:	85 ff       	sbrs	r24, 5
 648:	fd cf       	rjmp	.-6      	; 0x644 <UART_setColor+0x64>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 64a:	8d e6       	ldi	r24, 0x6D	; 109
 64c:	86 83       	std	Z+6, r24	; 0x06

    UART_puts(com,"\x1B["); //incio del comando espace
    UART_putchar(com, '0'+(color/10));
    UART_putchar(com,'0'+(color%10));
    UART_putchar(com,'m'); //final del comando
 }
 64e:	1f 91       	pop	r17
 650:	0f 91       	pop	r16
 652:	08 95       	ret

00000654 <itoa>:




// Utils
void itoa(uint16_t number, char* str, uint8_t base){
 654:	0f 93       	push	r16
 656:	1f 93       	push	r17
 658:	df 93       	push	r29
 65a:	cf 93       	push	r28
 65c:	cd b7       	in	r28, 0x3d	; 61
 65e:	de b7       	in	r29, 0x3e	; 62
 660:	a1 97       	sbiw	r28, 0x21	; 33
 662:	0f b6       	in	r0, 0x3f	; 63
 664:	f8 94       	cli
 666:	de bf       	out	0x3e, r29	; 62
 668:	0f be       	out	0x3f, r0	; 63
 66a:	cd bf       	out	0x3d, r28	; 61


    char *aux= str;

    if(base == 16){
 66c:	40 31       	cpi	r20, 0x10	; 16
 66e:	a1 f5       	brne	.+104    	; 0x6d8 <itoa+0x84>

        //asignamos un arreglo con las representaciones de los numero HEX en ASCI
        char hex[] = "0123456789ABCDEF";
 670:	de 01       	movw	r26, r28
 672:	51 96       	adiw	r26, 0x11	; 17
 674:	ef e2       	ldi	r30, 0x2F	; 47
 676:	f2 e0       	ldi	r31, 0x02	; 2
 678:	21 e1       	ldi	r18, 0x11	; 17
 67a:	01 90       	ld	r0, Z+
 67c:	0d 92       	st	X+, r0
 67e:	21 50       	subi	r18, 0x01	; 1
 680:	e1 f7       	brne	.-8      	; 0x67a <itoa+0x26>
        uint8_t index = 0;
        uint16_t temp = number; //hacemos un backup de number para trbajar con el y no pereder el valor original

        // Manejar el caso cuando el número es 0
        if (temp == 0) {
 682:	00 97       	sbiw	r24, 0x00	; 0
 684:	69 f1       	breq	.+90     	; 0x6e0 <itoa+0x8c>
            aux[index++] = '0';
            aux[index] = '\0';
            return;
 686:	9c 01       	movw	r18, r24
 688:	90 e0       	ldi	r25, 0x00	; 0
        //asi como un idx el cual controla cunatos digitiso tiene el numero
        char buffer[16];
        uint8_t buf_idx = 0;

        while (temp > 0) {
            buffer[buf_idx++] = hex[temp % base];
 68a:	ae 01       	movw	r20, r28
 68c:	4f 5f       	subi	r20, 0xFF	; 255
 68e:	5f 4f       	sbci	r21, 0xFF	; 255
 690:	8e 01       	movw	r16, r28
 692:	0f 5e       	subi	r16, 0xEF	; 239
 694:	1f 4f       	sbci	r17, 0xFF	; 255
 696:	fa 01       	movw	r30, r20
 698:	e9 0f       	add	r30, r25
 69a:	f1 1d       	adc	r31, r1
 69c:	d9 01       	movw	r26, r18
 69e:	af 70       	andi	r26, 0x0F	; 15
 6a0:	b0 70       	andi	r27, 0x00	; 0
 6a2:	a0 0f       	add	r26, r16
 6a4:	b1 1f       	adc	r27, r17
 6a6:	8c 91       	ld	r24, X
 6a8:	80 83       	st	Z, r24
 6aa:	9f 5f       	subi	r25, 0xFF	; 255
            temp /= base;
 6ac:	e4 e0       	ldi	r30, 0x04	; 4
 6ae:	36 95       	lsr	r19
 6b0:	27 95       	ror	r18
 6b2:	ea 95       	dec	r30
 6b4:	e1 f7       	brne	.-8      	; 0x6ae <itoa+0x5a>

        //asi como un idx el cual controla cunatos digitiso tiene el numero
        char buffer[16];
        uint8_t buf_idx = 0;

        while (temp > 0) {
 6b6:	21 15       	cp	r18, r1
 6b8:	31 05       	cpc	r19, r1
 6ba:	69 f7       	brne	.-38     	; 0x696 <itoa+0x42>
 6bc:	fa 01       	movw	r30, r20
 6be:	e9 0f       	add	r30, r25
 6c0:	f1 1d       	adc	r31, r1
 6c2:	db 01       	movw	r26, r22
 6c4:	02 c0       	rjmp	.+4      	; 0x6ca <itoa+0x76>

            pero 523 en HEX es -  20B, por lo uqe haceos como si fuera una pila si lo podemos ver asi
        */
        // Invertir la cadena
        for (int i = buf_idx - 1; i >= 0; i--) {
            aux[index++] = buffer[i];
 6c6:	80 81       	ld	r24, Z
 6c8:	8d 93       	st	X+, r24
 6ca:	31 97       	sbiw	r30, 0x01	; 1
            523 se puede diviir 3 veces por 16 el cual da en la primea 11 - 0 - 2

            pero 523 en HEX es -  20B, por lo uqe haceos como si fuera una pila si lo podemos ver asi
        */
        // Invertir la cadena
        for (int i = buf_idx - 1; i >= 0; i--) {
 6cc:	ec 17       	cp	r30, r28
 6ce:	fd 07       	cpc	r31, r29
 6d0:	d1 f7       	brne	.-12     	; 0x6c6 <itoa+0x72>
            aux[index++] = buffer[i];
        }
        aux[index] = '\0'; // Terminar con nulo
 6d2:	69 0f       	add	r22, r25
 6d4:	71 1d       	adc	r23, r1
 6d6:	3d c0       	rjmp	.+122    	; 0x752 <itoa+0xfe>


    }


    else if(base == 2){
 6d8:	42 30       	cpi	r20, 0x02	; 2
 6da:	e9 f5       	brne	.+122    	; 0x756 <itoa+0x102>

        //con el binario es un poco mas sencillo pero el proceso es el mismo

        //verificamos si el numero es 0 entonces volvemos a mandar le 0 no tiene caso que
        //se pierda tiempo en un proceso que incluso nos puede dar error
        if(number ==0){
 6dc:	00 97       	sbiw	r24, 0x00	; 0
 6de:	29 f4       	brne	.+10     	; 0x6ea <itoa+0x96>

            aux[index++] = '0';
 6e0:	80 e3       	ldi	r24, 0x30	; 48
 6e2:	fb 01       	movw	r30, r22
 6e4:	80 83       	st	Z, r24
            aux[index] = '\0';
 6e6:	11 82       	std	Z+1, r1	; 0x01
 6e8:	36 c0       	rjmp	.+108    	; 0x756 <itoa+0x102>
            return;
 6ea:	20 e0       	ldi	r18, 0x00	; 0



        while(temp > 0){

            buffer[buf_idx++]= (temp%2)?'1':'0';
 6ec:	ae 01       	movw	r20, r28
 6ee:	4f 5e       	subi	r20, 0xEF	; 239
 6f0:	5f 4f       	sbci	r21, 0xFF	; 255
 6f2:	80 fd       	sbrc	r24, 0
 6f4:	02 c0       	rjmp	.+4      	; 0x6fa <itoa+0xa6>
 6f6:	30 e3       	ldi	r19, 0x30	; 48
 6f8:	01 c0       	rjmp	.+2      	; 0x6fc <itoa+0xa8>
 6fa:	31 e3       	ldi	r19, 0x31	; 49
 6fc:	fa 01       	movw	r30, r20
 6fe:	e2 0f       	add	r30, r18
 700:	f1 1d       	adc	r31, r1
 702:	30 83       	st	Z, r19
 704:	2f 5f       	subi	r18, 0xFF	; 255
            temp/=2;
 706:	96 95       	lsr	r25
 708:	87 95       	ror	r24
            return;
        }



        while(temp > 0){
 70a:	00 97       	sbiw	r24, 0x00	; 0
 70c:	91 f7       	brne	.-28     	; 0x6f2 <itoa+0x9e>
 70e:	06 c0       	rjmp	.+12     	; 0x71c <itoa+0xc8>


        //rellenar con ceros a la izqueirda

        while(buf_idx < 16){
            buffer[buf_idx++]= '0';
 710:	fc 01       	movw	r30, r24
 712:	e2 0f       	add	r30, r18
 714:	f1 1d       	adc	r31, r1
 716:	30 83       	st	Z, r19
 718:	2f 5f       	subi	r18, 0xFF	; 255
 71a:	03 c0       	rjmp	.+6      	; 0x722 <itoa+0xce>
 71c:	ce 01       	movw	r24, r28
 71e:	41 96       	adiw	r24, 0x11	; 17
 720:	30 e3       	ldi	r19, 0x30	; 48
        }


        //rellenar con ceros a la izqueirda

        while(buf_idx < 16){
 722:	20 31       	cpi	r18, 0x10	; 16
 724:	a8 f3       	brcs	.-22     	; 0x710 <itoa+0xbc>
            buffer[buf_idx++]= '0';
        }

        index=0;

        for(int8_t i = buf_idx-1 ; i >= 0 ; i--){
 726:	42 2f       	mov	r20, r18
 728:	41 50       	subi	r20, 0x01	; 1
 72a:	a4 2f       	mov	r26, r20
 72c:	bb 27       	eor	r27, r27
 72e:	a7 fd       	sbrc	r26, 7
 730:	b0 95       	com	r27
 732:	a8 0f       	add	r26, r24
 734:	b9 1f       	adc	r27, r25
 736:	56 2f       	mov	r21, r22
 738:	cb 01       	movw	r24, r22
 73a:	fc 01       	movw	r30, r24
 73c:	04 c0       	rjmp	.+8      	; 0x746 <itoa+0xf2>
            aux[index++] = buffer[i];
 73e:	8c 91       	ld	r24, X
 740:	81 93       	st	Z+, r24
            buffer[buf_idx++]= '0';
        }

        index=0;

        for(int8_t i = buf_idx-1 ; i >= 0 ; i--){
 742:	41 50       	subi	r20, 0x01	; 1
 744:	11 97       	sbiw	r26, 0x01	; 1
 746:	8e 2f       	mov	r24, r30
 748:	85 1b       	sub	r24, r21
 74a:	47 ff       	sbrs	r20, 7
 74c:	f8 cf       	rjmp	.-16     	; 0x73e <itoa+0xea>
            aux[index++] = buffer[i];
        }

        aux[index]='\0';
 74e:	68 0f       	add	r22, r24
 750:	71 1d       	adc	r23, r1
 752:	fb 01       	movw	r30, r22
 754:	10 82       	st	Z, r1


    }

}
 756:	a1 96       	adiw	r28, 0x21	; 33
 758:	0f b6       	in	r0, 0x3f	; 63
 75a:	f8 94       	cli
 75c:	de bf       	out	0x3e, r29	; 62
 75e:	0f be       	out	0x3f, r0	; 63
 760:	cd bf       	out	0x3d, r28	; 61
 762:	cf 91       	pop	r28
 764:	df 91       	pop	r29
 766:	1f 91       	pop	r17
 768:	0f 91       	pop	r16
 76a:	08 95       	ret

0000076c <atoi>:



uint16_t atoi(char *str) {
 76c:	fc 01       	movw	r30, r24
 76e:	20 e0       	ldi	r18, 0x00	; 0
 770:	30 e0       	ldi	r19, 0x00	; 0
 772:	15 c0       	rjmp	.+42     	; 0x79e <atoi+0x32>
    uint16_t result = 0;
    while (*str != '\0') {
        if (*str >= '0' && *str <= '9') {
 774:	84 2f       	mov	r24, r20
 776:	80 53       	subi	r24, 0x30	; 48
 778:	8a 30       	cpi	r24, 0x0A	; 10
 77a:	80 f4       	brcc	.+32     	; 0x79c <atoi+0x30>
            result = result * 10 + (*str - '0');
 77c:	c9 01       	movw	r24, r18
 77e:	b3 e0       	ldi	r27, 0x03	; 3
 780:	88 0f       	add	r24, r24
 782:	99 1f       	adc	r25, r25
 784:	ba 95       	dec	r27
 786:	e1 f7       	brne	.-8      	; 0x780 <atoi+0x14>
 788:	22 0f       	add	r18, r18
 78a:	33 1f       	adc	r19, r19
 78c:	82 0f       	add	r24, r18
 78e:	93 1f       	adc	r25, r19
 790:	24 2f       	mov	r18, r20
 792:	30 e0       	ldi	r19, 0x00	; 0
 794:	20 53       	subi	r18, 0x30	; 48
 796:	30 40       	sbci	r19, 0x00	; 0
 798:	28 0f       	add	r18, r24
 79a:	39 1f       	adc	r19, r25
        }
        str++;
 79c:	31 96       	adiw	r30, 0x01	; 1



uint16_t atoi(char *str) {
    uint16_t result = 0;
    while (*str != '\0') {
 79e:	40 81       	ld	r20, Z
 7a0:	44 23       	and	r20, r20
 7a2:	41 f7       	brne	.-48     	; 0x774 <atoi+0x8>
            result = result * 10 + (*str - '0');
        }
        str++;
    }
    return result;
}
 7a4:	c9 01       	movw	r24, r18
 7a6:	08 95       	ret

000007a8 <__udivmodqi4>:
 7a8:	99 1b       	sub	r25, r25
 7aa:	79 e0       	ldi	r23, 0x09	; 9
 7ac:	04 c0       	rjmp	.+8      	; 0x7b6 <__udivmodqi4_ep>

000007ae <__udivmodqi4_loop>:
 7ae:	99 1f       	adc	r25, r25
 7b0:	96 17       	cp	r25, r22
 7b2:	08 f0       	brcs	.+2      	; 0x7b6 <__udivmodqi4_ep>
 7b4:	96 1b       	sub	r25, r22

000007b6 <__udivmodqi4_ep>:
 7b6:	88 1f       	adc	r24, r24
 7b8:	7a 95       	dec	r23
 7ba:	c9 f7       	brne	.-14     	; 0x7ae <__udivmodqi4_loop>
 7bc:	80 95       	com	r24
 7be:	08 95       	ret

000007c0 <__udivmodsi4>:
 7c0:	a1 e2       	ldi	r26, 0x21	; 33
 7c2:	1a 2e       	mov	r1, r26
 7c4:	aa 1b       	sub	r26, r26
 7c6:	bb 1b       	sub	r27, r27
 7c8:	fd 01       	movw	r30, r26
 7ca:	0d c0       	rjmp	.+26     	; 0x7e6 <__udivmodsi4_ep>

000007cc <__udivmodsi4_loop>:
 7cc:	aa 1f       	adc	r26, r26
 7ce:	bb 1f       	adc	r27, r27
 7d0:	ee 1f       	adc	r30, r30
 7d2:	ff 1f       	adc	r31, r31
 7d4:	a2 17       	cp	r26, r18
 7d6:	b3 07       	cpc	r27, r19
 7d8:	e4 07       	cpc	r30, r20
 7da:	f5 07       	cpc	r31, r21
 7dc:	20 f0       	brcs	.+8      	; 0x7e6 <__udivmodsi4_ep>
 7de:	a2 1b       	sub	r26, r18
 7e0:	b3 0b       	sbc	r27, r19
 7e2:	e4 0b       	sbc	r30, r20
 7e4:	f5 0b       	sbc	r31, r21

000007e6 <__udivmodsi4_ep>:
 7e6:	66 1f       	adc	r22, r22
 7e8:	77 1f       	adc	r23, r23
 7ea:	88 1f       	adc	r24, r24
 7ec:	99 1f       	adc	r25, r25
 7ee:	1a 94       	dec	r1
 7f0:	69 f7       	brne	.-38     	; 0x7cc <__udivmodsi4_loop>
 7f2:	60 95       	com	r22
 7f4:	70 95       	com	r23
 7f6:	80 95       	com	r24
 7f8:	90 95       	com	r25
 7fa:	9b 01       	movw	r18, r22
 7fc:	ac 01       	movw	r20, r24
 7fe:	bd 01       	movw	r22, r26
 800:	cf 01       	movw	r24, r30
 802:	08 95       	ret

00000804 <_exit>:
 804:	f8 94       	cli

00000806 <__stop_program>:
 806:	ff cf       	rjmp	.-2      	; 0x806 <__stop_program>
