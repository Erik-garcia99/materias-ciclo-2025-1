
practica6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000048  00800200  000007d8  0000084c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000007d8  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .debug_aranges 00000040  00000000  00000000  00000894  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 000000ef  00000000  00000000  000008d4  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000a7b  00000000  00000000  000009c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 0000032d  00000000  00000000  0000143e  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000742  00000000  00000000  0000176b  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  000000f0  00000000  00000000  00001eb0  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    0000022e  00000000  00000000  00001fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    00000723  00000000  00000000  000021ce  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 000001b0  00000000  00000000  000028f1  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  10:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  14:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  18:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  1c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  20:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  24:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  28:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  2c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  30:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  34:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  38:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  3c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  40:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  44:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  48:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  4c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  50:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  54:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  58:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  5c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  60:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  64:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  68:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  6c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  70:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  74:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  78:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  7c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  80:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  84:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  88:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  8c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  90:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  94:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  98:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  9c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  ac:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  bc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  cc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  dc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  e0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	e8 ed       	ldi	r30, 0xD8	; 216
  fc:	f7 e0       	ldi	r31, 0x07	; 7
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a8 34       	cpi	r26, 0x48	; 72
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
 10e:	0e 94 8d 00 	call	0x11a	; 0x11a <main>
 112:	0c 94 ea 03 	jmp	0x7d4	; 0x7d4 <_exit>

00000116 <__bad_interrupt>:
 116:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000011a <main>:
#include "UART.h"



int main( void )
{
 11a:	cf 92       	push	r12
 11c:	df 92       	push	r13
 11e:	ef 92       	push	r14
 120:	ff 92       	push	r15
 122:	0f 93       	push	r16
 124:	1f 93       	push	r17
 126:	df 93       	push	r29
 128:	cf 93       	push	r28
 12a:	cd b7       	in	r28, 0x3d	; 61
 12c:	de b7       	in	r29, 0x3e	; 62
 12e:	a8 97       	sbiw	r28, 0x28	; 40
 130:	0f b6       	in	r0, 0x3f	; 63
 132:	f8 94       	cli
 134:	de bf       	out	0x3e, r29	; 62
 136:	0f be       	out	0x3f, r0	; 63
 138:	cd bf       	out	0x3d, r28	; 61
    char cad[20];
    char cadUart3[20];
    uint16_t num;


    UART_Ini(0,12345,8,1,2); //comunicacion con teraterm
 13a:	80 e0       	ldi	r24, 0x00	; 0
 13c:	49 e3       	ldi	r20, 0x39	; 57
 13e:	50 e3       	ldi	r21, 0x30	; 48
 140:	60 e0       	ldi	r22, 0x00	; 0
 142:	70 e0       	ldi	r23, 0x00	; 0
 144:	28 e0       	ldi	r18, 0x08	; 8
 146:	01 e0       	ldi	r16, 0x01	; 1
 148:	92 e0       	ldi	r25, 0x02	; 2
 14a:	e9 2e       	mov	r14, r25
 14c:	0e 94 29 01 	call	0x252	; 0x252 <UART_Ini>
    UART_Ini(2,115200,8,0,1);
 150:	82 e0       	ldi	r24, 0x02	; 2
 152:	40 e0       	ldi	r20, 0x00	; 0
 154:	52 ec       	ldi	r21, 0xC2	; 194
 156:	61 e0       	ldi	r22, 0x01	; 1
 158:	70 e0       	ldi	r23, 0x00	; 0
 15a:	28 e0       	ldi	r18, 0x08	; 8
 15c:	00 e0       	ldi	r16, 0x00	; 0
 15e:	ee 24       	eor	r14, r14
 160:	e3 94       	inc	r14
 162:	0e 94 29 01 	call	0x252	; 0x252 <UART_Ini>
    UART_Ini(3,115200,8,0,1);
 166:	83 e0       	ldi	r24, 0x03	; 3
 168:	40 e0       	ldi	r20, 0x00	; 0
 16a:	52 ec       	ldi	r21, 0xC2	; 194
 16c:	61 e0       	ldi	r22, 0x01	; 1
 16e:	70 e0       	ldi	r23, 0x00	; 0
 170:	28 e0       	ldi	r18, 0x08	; 8
 172:	0e 94 29 01 	call	0x252	; 0x252 <UART_Ini>
        UART_setColor(0,YELLOW);
        UART_puts(0,"Introduce un n?mero:"); //terminamos con un caracter nulo, funciona bien puts

        UART_gotoxy(0,22,2);
        UART_setColor(0,GREEN);
        UART_gets(0,cad); //vreremos si este funciona correcto
 176:	7e 01       	movw	r14, r28
 178:	08 94       	sec
 17a:	e1 1c       	adc	r14, r1
 17c:	f1 1c       	adc	r15, r1
// -------------------------------------------
        // Cycle through UART2->UART3
        UART_puts(2,cad);
        UART_puts(2,"\r");
        UART_gets(3,cadUart3);
 17e:	85 e1       	ldi	r24, 0x15	; 21
 180:	c8 2e       	mov	r12, r24
 182:	d1 2c       	mov	r13, r1
 184:	cc 0e       	add	r12, r28
 186:	dd 1e       	adc	r13, r29
    UART_Ini(0,12345,8,1,2); //comunicacion con teraterm
    UART_Ini(2,115200,8,0,1);
    UART_Ini(3,115200,8,0,1);
    while(1)
    {
        UART_getchar(0);//getchar funciona OK
 188:	80 e0       	ldi	r24, 0x00	; 0
 18a:	0e 94 bc 01 	call	0x378	; 0x378 <UART_getchar>
        UART_clrscr(0);
 18e:	80 e0       	ldi	r24, 0x00	; 0
 190:	0e 94 54 02 	call	0x4a8	; 0x4a8 <UART_clrscr>

        UART_gotoxy(0,2,2);
 194:	80 e0       	ldi	r24, 0x00	; 0
 196:	62 e0       	ldi	r22, 0x02	; 2
 198:	42 e0       	ldi	r20, 0x02	; 2
 19a:	0e 94 a2 02 	call	0x544	; 0x544 <UART_gotoxy>
        UART_setColor(0,YELLOW);
 19e:	80 e0       	ldi	r24, 0x00	; 0
 1a0:	61 e2       	ldi	r22, 0x21	; 33
 1a2:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <UART_setColor>
        UART_puts(0,"Introduce un n?mero:"); //terminamos con un caracter nulo, funciona bien puts
 1a6:	80 e0       	ldi	r24, 0x00	; 0
 1a8:	60 e0       	ldi	r22, 0x00	; 0
 1aa:	72 e0       	ldi	r23, 0x02	; 2
 1ac:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>

        UART_gotoxy(0,22,2);
 1b0:	80 e0       	ldi	r24, 0x00	; 0
 1b2:	66 e1       	ldi	r22, 0x16	; 22
 1b4:	42 e0       	ldi	r20, 0x02	; 2
 1b6:	0e 94 a2 02 	call	0x544	; 0x544 <UART_gotoxy>
        UART_setColor(0,GREEN);
 1ba:	80 e0       	ldi	r24, 0x00	; 0
 1bc:	60 e2       	ldi	r22, 0x20	; 32
 1be:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <UART_setColor>
        UART_gets(0,cad); //vreremos si este funciona correcto
 1c2:	80 e0       	ldi	r24, 0x00	; 0
 1c4:	b7 01       	movw	r22, r14
 1c6:	0e 94 ca 01 	call	0x394	; 0x394 <UART_gets>
// -------------------------------------------
        // Cycle through UART2->UART3
        UART_puts(2,cad);
 1ca:	82 e0       	ldi	r24, 0x02	; 2
 1cc:	b7 01       	movw	r22, r14
 1ce:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        UART_puts(2,"\r");
 1d2:	82 e0       	ldi	r24, 0x02	; 2
 1d4:	65 e1       	ldi	r22, 0x15	; 21
 1d6:	72 e0       	ldi	r23, 0x02	; 2
 1d8:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        UART_gets(3,cadUart3);
 1dc:	83 e0       	ldi	r24, 0x03	; 3
 1de:	b6 01       	movw	r22, r12
 1e0:	0e 94 ca 01 	call	0x394	; 0x394 <UART_gets>
        UART_gotoxy(0,5,3);
 1e4:	80 e0       	ldi	r24, 0x00	; 0
 1e6:	65 e0       	ldi	r22, 0x05	; 5
 1e8:	43 e0       	ldi	r20, 0x03	; 3
 1ea:	0e 94 a2 02 	call	0x544	; 0x544 <UART_gotoxy>
        UART_puts(0,cadUart3);
 1ee:	80 e0       	ldi	r24, 0x00	; 0
 1f0:	b6 01       	movw	r22, r12
 1f2:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
// -------------------------------------------
        num = atoi(cad);
 1f6:	c7 01       	movw	r24, r14
 1f8:	0e 94 9e 03 	call	0x73c	; 0x73c <atoi>
 1fc:	8c 01       	movw	r16, r24
        itoa(num,cad,16);
 1fe:	b7 01       	movw	r22, r14
 200:	40 e1       	ldi	r20, 0x10	; 16
 202:	0e 94 12 03 	call	0x624	; 0x624 <itoa>

        UART_gotoxy(0,5,4);
 206:	80 e0       	ldi	r24, 0x00	; 0
 208:	65 e0       	ldi	r22, 0x05	; 5
 20a:	44 e0       	ldi	r20, 0x04	; 4
 20c:	0e 94 a2 02 	call	0x544	; 0x544 <UART_gotoxy>
        UART_setColor(0,BLUE);
 210:	80 e0       	ldi	r24, 0x00	; 0
 212:	62 e2       	ldi	r22, 0x22	; 34
 214:	0e 94 d8 02 	call	0x5b0	; 0x5b0 <UART_setColor>
        UART_puts(0,"Hex: ");
 218:	80 e0       	ldi	r24, 0x00	; 0
 21a:	67 e1       	ldi	r22, 0x17	; 23
 21c:	72 e0       	ldi	r23, 0x02	; 2
 21e:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        UART_puts(0,cad);
 222:	80 e0       	ldi	r24, 0x00	; 0
 224:	b7 01       	movw	r22, r14
 226:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        itoa(num,cad,2);
 22a:	c8 01       	movw	r24, r16
 22c:	b7 01       	movw	r22, r14
 22e:	42 e0       	ldi	r20, 0x02	; 2
 230:	0e 94 12 03 	call	0x624	; 0x624 <itoa>

        UART_gotoxy(0,5,5);
 234:	80 e0       	ldi	r24, 0x00	; 0
 236:	65 e0       	ldi	r22, 0x05	; 5
 238:	45 e0       	ldi	r20, 0x05	; 5
 23a:	0e 94 a2 02 	call	0x544	; 0x544 <UART_gotoxy>
        UART_puts(0,"Bin: ");
 23e:	80 e0       	ldi	r24, 0x00	; 0
 240:	6d e1       	ldi	r22, 0x1D	; 29
 242:	72 e0       	ldi	r23, 0x02	; 2
 244:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
        UART_puts(0,cad);
 248:	80 e0       	ldi	r24, 0x00	; 0
 24a:	b7 01       	movw	r22, r14
 24c:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
 250:	9b cf       	rjmp	.-202    	; 0x188 <main+0x6e>

00000252 <UART_Ini>:

};



UART_Ini(uint8_t com, uint32_t baudrate, uint8_t size, uint8_t parity, uint8_t stop){
 252:	af 92       	push	r10
 254:	bf 92       	push	r11
 256:	cf 92       	push	r12
 258:	df 92       	push	r13
 25a:	ef 92       	push	r14
 25c:	0f 93       	push	r16
 25e:	cf 93       	push	r28
 260:	df 93       	push	r29
 262:	5a 01       	movw	r10, r20
 264:	6b 01       	movw	r12, r22
 266:	92 2f       	mov	r25, r18
 268:	2e 2d       	mov	r18, r14

    UART_reg_t *myUART = UART_offset[com]; // eligo a mi UART
 26a:	e8 2f       	mov	r30, r24
 26c:	f0 e0       	ldi	r31, 0x00	; 0
 26e:	ee 0f       	add	r30, r30
 270:	ff 1f       	adc	r31, r31
 272:	e0 5c       	subi	r30, 0xC0	; 192
 274:	fd 4f       	sbci	r31, 0xFD	; 253
 276:	c0 81       	ld	r28, Z
 278:	d1 81       	ldd	r29, Z+1	; 0x01

    myUART->UCSRB = (1 << TXEN0) | (1 << RXEN0); // Habilita TX y RX para UART0
 27a:	88 e1       	ldi	r24, 0x18	; 24
 27c:	89 83       	std	Y+1, r24	; 0x01
    //establecer las paridades
	//uint8_t parity_mode= (parity == 1) ? 2 : 3;  // 2: Paridad par, 3: Paridad impar

    uint8_t parity_mode=0;

    switch(parity){
 27e:	01 30       	cpi	r16, 0x01	; 1
 280:	21 f0       	breq	.+8      	; 0x28a <UART_Ini+0x38>
 282:	02 30       	cpi	r16, 0x02	; 2
 284:	21 f4       	brne	.+8      	; 0x28e <UART_Ini+0x3c>
 286:	82 e0       	ldi	r24, 0x02	; 2
 288:	03 c0       	rjmp	.+6      	; 0x290 <UART_Ini+0x3e>
 28a:	83 e0       	ldi	r24, 0x03	; 3
 28c:	01 c0       	rjmp	.+2      	; 0x290 <UART_Ini+0x3e>
 28e:	80 e0       	ldi	r24, 0x00	; 0
    //me manda sde de 1 o 2 por lo que ocn este ternearo decivo si es 1 sera 1 bit de parada 0
    //pero si es otro valor seran 2 bits de parada

    uint8_t stop_mode= (stop == 1)? 0:1;

    myUART->UCSRC = (parity_mode << UPM00) | (stop_mode <<USBS0);
 290:	e8 2f       	mov	r30, r24
 292:	f0 e0       	ldi	r31, 0x00	; 0
 294:	54 e0       	ldi	r21, 0x04	; 4
 296:	ee 0f       	add	r30, r30
 298:	ff 1f       	adc	r31, r31
 29a:	5a 95       	dec	r21
 29c:	e1 f7       	brne	.-8      	; 0x296 <UART_Ini+0x44>
 29e:	60 e0       	ldi	r22, 0x00	; 0
 2a0:	70 e0       	ldi	r23, 0x00	; 0
 2a2:	21 30       	cpi	r18, 0x01	; 1
 2a4:	11 f0       	breq	.+4      	; 0x2aa <UART_Ini+0x58>
 2a6:	61 e0       	ldi	r22, 0x01	; 1
 2a8:	70 e0       	ldi	r23, 0x00	; 0
 2aa:	43 e0       	ldi	r20, 0x03	; 3
 2ac:	66 0f       	add	r22, r22
 2ae:	77 1f       	adc	r23, r23
 2b0:	4a 95       	dec	r20
 2b2:	e1 f7       	brne	.-8      	; 0x2ac <UART_Ini+0x5a>
 2b4:	8e 2f       	mov	r24, r30
 2b6:	86 2b       	or	r24, r22
 2b8:	8a 83       	std	Y+2, r24	; 0x02

		myUART->UCSRC = 3 << UCSZ00;
		myUART->UCSRB = 1<< UCSZ02; //habilitamos los 9 bits
	}*/

	if (size == 9) {
 2ba:	99 30       	cpi	r25, 0x09	; 9
 2bc:	39 f4       	brne	.+14     	; 0x2cc <UART_Ini+0x7a>
        myUART->UCSRC |= (3 << UCSZ00); // UCSZ01:UCSZ00 = 0b11
 2be:	8a 81       	ldd	r24, Y+2	; 0x02
 2c0:	86 60       	ori	r24, 0x06	; 6
 2c2:	8a 83       	std	Y+2, r24	; 0x02
        myUART->UCSRB |= (1 << UCSZ02); // Habilitar bit 9
 2c4:	89 81       	ldd	r24, Y+1	; 0x01
 2c6:	84 60       	ori	r24, 0x04	; 4
 2c8:	89 83       	std	Y+1, r24	; 0x01
 2ca:	08 c0       	rjmp	.+16     	; 0x2dc <UART_Ini+0x8a>
    } else
     {
        myUART->UCSRC |= ((size - 5) << UCSZ00); // Ej: 8 bits ? 3 << UCSZ00
 2cc:	2a 81       	ldd	r18, Y+2	; 0x02
 2ce:	89 2f       	mov	r24, r25
 2d0:	90 e0       	ldi	r25, 0x00	; 0
 2d2:	05 97       	sbiw	r24, 0x05	; 5
 2d4:	88 0f       	add	r24, r24
 2d6:	99 1f       	adc	r25, r25
 2d8:	28 2b       	or	r18, r24
 2da:	2a 83       	std	Y+2, r18	; 0x02
    }

    uint16_t v_UBRR = (FOSC / (16 * baudrate)) - 1 ;
 2dc:	84 e0       	ldi	r24, 0x04	; 4
 2de:	aa 0c       	add	r10, r10
 2e0:	bb 1c       	adc	r11, r11
 2e2:	cc 1c       	adc	r12, r12
 2e4:	dd 1c       	adc	r13, r13
 2e6:	8a 95       	dec	r24
 2e8:	d1 f7       	brne	.-12     	; 0x2de <UART_Ini+0x8c>
 2ea:	60 e0       	ldi	r22, 0x00	; 0
 2ec:	74 e2       	ldi	r23, 0x24	; 36
 2ee:	84 ef       	ldi	r24, 0xF4	; 244
 2f0:	90 e0       	ldi	r25, 0x00	; 0
 2f2:	a6 01       	movw	r20, r12
 2f4:	95 01       	movw	r18, r10
 2f6:	0e 94 c8 03 	call	0x790	; 0x790 <__udivmodsi4>
 2fa:	21 50       	subi	r18, 0x01	; 1
 2fc:	30 40       	sbci	r19, 0x00	; 0
    myUART->UBRR = v_UBRR;
 2fe:	3d 83       	std	Y+5, r19	; 0x05
 300:	2c 83       	std	Y+4, r18	; 0x04
}
 302:	df 91       	pop	r29
 304:	cf 91       	pop	r28
 306:	0f 91       	pop	r16
 308:	ef 90       	pop	r14
 30a:	df 90       	pop	r13
 30c:	cf 90       	pop	r12
 30e:	bf 90       	pop	r11
 310:	af 90       	pop	r10
 312:	08 95       	ret

00000314 <UART_puts>:
*/


//este haria lo mismo de putchar la unica deiferente es que este estara
//recorriendo la cadena que se quiere imprimir
void UART_puts(uint8_t com, char *str){
 314:	cf 93       	push	r28
 316:	df 93       	push	r29
 318:	eb 01       	movw	r28, r22
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 31a:	e8 2f       	mov	r30, r24
 31c:	f0 e0       	ldi	r31, 0x00	; 0
 31e:	ee 0f       	add	r30, r30
 320:	ff 1f       	adc	r31, r31
 322:	e0 5c       	subi	r30, 0xC0	; 192
 324:	fd 4f       	sbci	r31, 0xFD	; 253
 326:	08 c0       	rjmp	.+16     	; 0x338 <UART_puts+0x24>
 328:	a0 81       	ld	r26, Z
 32a:	b1 81       	ldd	r27, Z+1	; 0x01
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 32c:	8c 91       	ld	r24, X
 32e:	85 ff       	sbrs	r24, 5
 330:	fd cf       	rjmp	.-6      	; 0x32c <UART_puts+0x18>
void UART_puts(uint8_t com, char *str){

	//TXn trasmitir el contenido
	while(*str!= '\0'){
		//mientras haya contenido en el apuntador, que sea diferente a NULL
		UART_putchar(com,*str++);
 332:	21 96       	adiw	r28, 0x01	; 1

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 334:	16 96       	adiw	r26, 0x06	; 6
 336:	9c 93       	st	X, r25
//este haria lo mismo de putchar la unica deiferente es que este estara
//recorriendo la cadena que se quiere imprimir
void UART_puts(uint8_t com, char *str){

	//TXn trasmitir el contenido
	while(*str!= '\0'){
 338:	98 81       	ld	r25, Y
 33a:	99 23       	and	r25, r25
 33c:	a9 f7       	brne	.-22     	; 0x328 <UART_puts+0x14>
		//mientras haya contenido en el apuntador, que sea diferente a NULL
		UART_putchar(com,*str++);
	}
}
 33e:	df 91       	pop	r29
 340:	cf 91       	pop	r28
 342:	08 95       	ret

00000344 <UART_putchar>:
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 344:	e8 2f       	mov	r30, r24
 346:	f0 e0       	ldi	r31, 0x00	; 0
 348:	ee 0f       	add	r30, r30
 34a:	ff 1f       	adc	r31, r31
 34c:	e0 5c       	subi	r30, 0xC0	; 192
 34e:	fd 4f       	sbci	r31, 0xFD	; 253
 350:	01 90       	ld	r0, Z+
 352:	f0 81       	ld	r31, Z
 354:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 356:	80 81       	ld	r24, Z
 358:	85 ff       	sbrs	r24, 5
 35a:	fd cf       	rjmp	.-6      	; 0x356 <UART_putchar+0x12>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 35c:	66 83       	std	Z+6, r22	; 0x06
}
 35e:	08 95       	ret

00000360 <UART_available>:
uint8_t UART_available(uint8_t com){

	//RXC0 sta en 1 cuando hay un dato sin leer en RXC
	//y esta en 0 cunado este no tiene nada

	UART_reg_t *myUART = UART_offset[com];
 360:	e8 2f       	mov	r30, r24
 362:	f0 e0       	ldi	r31, 0x00	; 0
 364:	ee 0f       	add	r30, r30
 366:	ff 1f       	adc	r31, r31
 368:	e0 5c       	subi	r30, 0xC0	; 192
 36a:	fd 4f       	sbci	r31, 0xFD	; 253
 36c:	01 90       	ld	r0, Z+
 36e:	f0 81       	ld	r31, Z
 370:	e0 2d       	mov	r30, r0

	return (myUART->UCSRA & (1 << RXC0)) ; // Hay dato disponible
 372:	80 81       	ld	r24, Z
	//creo que va a asi pero si hay errores podemos invertirlo
}
 374:	80 78       	andi	r24, 0x80	; 128
 376:	08 95       	ret

00000378 <UART_getchar>:
	return myUART->UDR;
}*/


char UART_getchar(uint8_t com) {
    UART_reg_t *myUART = UART_offset[com];
 378:	e8 2f       	mov	r30, r24
 37a:	f0 e0       	ldi	r31, 0x00	; 0
 37c:	ee 0f       	add	r30, r30
 37e:	ff 1f       	adc	r31, r31
 380:	e0 5c       	subi	r30, 0xC0	; 192
 382:	fd 4f       	sbci	r31, 0xFD	; 253
 384:	01 90       	ld	r0, Z+
 386:	f0 81       	ld	r31, Z
 388:	e0 2d       	mov	r30, r0
    while (!(myUART->UCSRA & (1 << RXC0))); // Espera dato
 38a:	80 81       	ld	r24, Z
 38c:	87 ff       	sbrs	r24, 7
 38e:	fd cf       	rjmp	.-6      	; 0x38a <UART_getchar+0x12>
    return myUART->UDR;
 390:	86 81       	ldd	r24, Z+6	; 0x06
}
 392:	08 95       	ret

00000394 <UART_gets>:


void UART_gets(uint8_t com, char *str){
 394:	cf 93       	push	r28
 396:	df 93       	push	r29
 398:	eb 01       	movw	r28, r22
 39a:	40 e0       	ldi	r20, 0x00	; 0
 39c:	50 e0       	ldi	r21, 0x00	; 0
	return myUART->UDR;
}*/


char UART_getchar(uint8_t com) {
    UART_reg_t *myUART = UART_offset[com];
 39e:	28 2f       	mov	r18, r24
 3a0:	30 e0       	ldi	r19, 0x00	; 0
 3a2:	d9 01       	movw	r26, r18
 3a4:	aa 0f       	add	r26, r26
 3a6:	bb 1f       	adc	r27, r27
 3a8:	a0 5c       	subi	r26, 0xC0	; 192
 3aa:	bd 4f       	sbci	r27, 0xFD	; 253

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 3ac:	68 e0       	ldi	r22, 0x08	; 8
    while (!(myUART->UCSRA & (1 << RXC0))); // Espera dato
    return myUART->UDR;
}


void UART_gets(uint8_t com, char *str){
 3ae:	70 e2       	ldi	r23, 0x20	; 32
 3b0:	01 c0       	rjmp	.+2      	; 0x3b4 <UART_gets+0x20>
 3b2:	51 e0       	ldi	r21, 0x01	; 1
	return myUART->UDR;
}*/


char UART_getchar(uint8_t com) {
    UART_reg_t *myUART = UART_offset[com];
 3b4:	ed 91       	ld	r30, X+
 3b6:	fc 91       	ld	r31, X
 3b8:	11 97       	sbiw	r26, 0x01	; 1
    while (!(myUART->UCSRA & (1 << RXC0))); // Espera dato
 3ba:	80 81       	ld	r24, Z
 3bc:	87 ff       	sbrs	r24, 7
 3be:	fd cf       	rjmp	.-6      	; 0x3ba <UART_gets+0x26>
    return myUART->UDR;
 3c0:	96 81       	ldd	r25, Z+6	; 0x06





		if(c=='\b'){
 3c2:	98 30       	cpi	r25, 0x08	; 8
 3c4:	e9 f4       	brne	.+58     	; 0x400 <UART_gets+0x6c>
			if(i>0){
 3c6:	44 23       	and	r20, r20
 3c8:	a9 f3       	breq	.-22     	; 0x3b4 <UART_gets+0x20>

				str[--i] = '\0'; //sustitumos el utlimo caracter con el nulo
 3ca:	41 50       	subi	r20, 0x01	; 1
 3cc:	fe 01       	movw	r30, r28
 3ce:	e4 0f       	add	r30, r20
 3d0:	f1 1d       	adc	r31, r1
 3d2:	10 82       	st	Z, r1
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 3d4:	ed 91       	ld	r30, X+
 3d6:	fc 91       	ld	r31, X
 3d8:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 3da:	80 81       	ld	r24, Z
 3dc:	85 ff       	sbrs	r24, 5
 3de:	fd cf       	rjmp	.-6      	; 0x3da <UART_gets+0x46>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 3e0:	66 83       	std	Z+6, r22	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 3e2:	ed 91       	ld	r30, X+
 3e4:	fc 91       	ld	r31, X
 3e6:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 3e8:	80 81       	ld	r24, Z
 3ea:	85 ff       	sbrs	r24, 5
 3ec:	fd cf       	rjmp	.-6      	; 0x3e8 <UART_gets+0x54>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 3ee:	76 83       	std	Z+6, r23	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 3f0:	ed 91       	ld	r30, X+
 3f2:	fc 91       	ld	r31, X
 3f4:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 3f6:	80 81       	ld	r24, Z
 3f8:	85 ff       	sbrs	r24, 5
 3fa:	fd cf       	rjmp	.-6      	; 0x3f6 <UART_gets+0x62>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 3fc:	66 83       	std	Z+6, r22	; 0x06
 3fe:	da cf       	rjmp	.-76     	; 0x3b4 <UART_gets+0x20>
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 400:	80 81       	ld	r24, Z
 402:	85 ff       	sbrs	r24, 5
 404:	fd cf       	rjmp	.-6      	; 0x400 <UART_gets+0x6c>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 406:	96 83       	std	Z+6, r25	; 0x06



		UART_putchar(com,c);

		if(c == '\r' || c== '\n'){
 408:	9d 30       	cpi	r25, 0x0D	; 13
 40a:	11 f0       	breq	.+4      	; 0x410 <UART_gets+0x7c>
 40c:	9a 30       	cpi	r25, 0x0A	; 10
 40e:	f9 f4       	brne	.+62     	; 0x44e <UART_gets+0xba>
		//retorno de carro o salto de linea lo que quiere decir que se terminao de escribir el
		//texto actual.

			str[i]='\0'; //caracter nulo denotando que la
 410:	c4 0f       	add	r28, r20
 412:	d1 1d       	adc	r29, r1
 414:	18 82       	st	Y, r1
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 416:	f9 01       	movw	r30, r18
 418:	ee 0f       	add	r30, r30
 41a:	ff 1f       	adc	r31, r31
 41c:	e0 5c       	subi	r30, 0xC0	; 192
 41e:	fd 4f       	sbci	r31, 0xFD	; 253
 420:	01 90       	ld	r0, Z+
 422:	f0 81       	ld	r31, Z
 424:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 426:	80 81       	ld	r24, Z
 428:	85 ff       	sbrs	r24, 5
 42a:	fd cf       	rjmp	.-6      	; 0x426 <UART_gets+0x92>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 42c:	8d e0       	ldi	r24, 0x0D	; 13
 42e:	86 83       	std	Z+6, r24	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 430:	22 0f       	add	r18, r18
 432:	33 1f       	adc	r19, r19
 434:	20 5c       	subi	r18, 0xC0	; 192
 436:	3d 4f       	sbci	r19, 0xFD	; 253
 438:	d9 01       	movw	r26, r18
 43a:	ed 91       	ld	r30, X+
 43c:	fc 91       	ld	r31, X
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 43e:	80 81       	ld	r24, Z
 440:	85 ff       	sbrs	r24, 5
 442:	fd cf       	rjmp	.-6      	; 0x43e <UART_gets+0xaa>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 444:	8a e0       	ldi	r24, 0x0A	; 10
 446:	86 83       	std	Z+6, r24	; 0x06
			UART_putchar(com, ' ');
			UART_putchar(com,'\b');
        }
	}

}
 448:	df 91       	pop	r29
 44a:	cf 91       	pop	r28
 44c:	08 95       	ret
			UART_putchar(com,'\r'); //vuelve al inicio de la linea
			UART_putchar(com,'\n'); //salto de linea
			break; //rompesmos el ciclo y a esperar que se vuelva a escribir algo
		}

		if (c == '.') {
 44e:	9e 32       	cpi	r25, 0x2E	; 46
 450:	09 f4       	brne	.+2      	; 0x454 <UART_gets+0xc0>
 452:	af cf       	rjmp	.-162    	; 0x3b2 <UART_gets+0x1e>
            dot_flag = 1;
            continue; // No muestra el punto
        }

        if(dot_flag){
 454:	55 23       	and	r21, r21
 456:	29 f0       	breq	.+10     	; 0x462 <UART_gets+0xce>
            lo que voy a hacer es que despues del punto sera coindierado 0,

            va amostrar por el UART pero despues lo cambiaremos a un caracter nulo todos los demas
            */

            str[i++] = '\0'; //desoues de este punto ya no lo tomara en cuenta
 458:	fe 01       	movw	r30, r28
 45a:	e4 0f       	add	r30, r20
 45c:	f1 1d       	adc	r31, r1
 45e:	10 82       	st	Z, r1
 460:	4f 5f       	subi	r20, 0xFF	; 255
 462:	e4 2f       	mov	r30, r20
 464:	f0 e0       	ldi	r31, 0x00	; 0
		}


		//para 20 caracteres, si no lo regresamos a 127

		if(i<19){
 466:	43 31       	cpi	r20, 0x13	; 19
 468:	28 f4       	brcc	.+10     	; 0x474 <UART_gets+0xe0>

			str[i++]= c;
 46a:	ec 0f       	add	r30, r28
 46c:	fd 1f       	adc	r31, r29
 46e:	90 83       	st	Z, r25
 470:	4f 5f       	subi	r20, 0xFF	; 255
 472:	18 c0       	rjmp	.+48     	; 0x4a4 <UART_gets+0x110>
				esta en el indece maximo +1 entonces lo que hace es como el borraro de ese sigueitne
				caractere por lo que parece que no se esta capturando pero lo que hace es que se esta borrando
				constantement lo que se captrua despues
			*/

			str[i] = '\0'; //sustitumos el utlimo caracter con el nulo
 474:	ec 0f       	add	r30, r28
 476:	fd 1f       	adc	r31, r29
 478:	10 82       	st	Z, r1
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 47a:	ed 91       	ld	r30, X+
 47c:	fc 91       	ld	r31, X
 47e:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 480:	80 81       	ld	r24, Z
 482:	85 ff       	sbrs	r24, 5
 484:	fd cf       	rjmp	.-6      	; 0x480 <UART_gets+0xec>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 486:	66 83       	std	Z+6, r22	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 488:	ed 91       	ld	r30, X+
 48a:	fc 91       	ld	r31, X
 48c:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 48e:	80 81       	ld	r24, Z
 490:	85 ff       	sbrs	r24, 5
 492:	fd cf       	rjmp	.-6      	; 0x48e <UART_gets+0xfa>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 494:	76 83       	std	Z+6, r23	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 496:	ed 91       	ld	r30, X+
 498:	fc 91       	ld	r31, X
 49a:	11 97       	sbiw	r26, 0x01	; 1
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 49c:	80 81       	ld	r24, Z
 49e:	85 ff       	sbrs	r24, 5
 4a0:	fd cf       	rjmp	.-6      	; 0x49c <UART_gets+0x108>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 4a2:	66 83       	std	Z+6, r22	; 0x06
 4a4:	50 e0       	ldi	r21, 0x00	; 0
 4a6:	86 cf       	rjmp	.-244    	; 0x3b4 <UART_gets+0x20>

000004a8 <UART_clrscr>:

}


// Escape sequences
UART_clrscr( uint8_t com ){
 4a8:	1f 93       	push	r17
 4aa:	18 2f       	mov	r17, r24
        que con ESC[2J se borra toda la pantalla

        lo mismo para con posicionar al inicio de la termianl
        sin parametros H se estbalce en la fila1 - columna1
    */
    UART_puts(com,"\x1B[2J"); //borra toda la pantalla
 4ac:	63 e2       	ldi	r22, 0x23	; 35
 4ae:	72 e0       	ldi	r23, 0x02	; 2
 4b0:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
    UART_puts(com,"\x1B[H"); // poen el curso al incio fila 1, columna 1
 4b4:	81 2f       	mov	r24, r17
 4b6:	68 e2       	ldi	r22, 0x28	; 40
 4b8:	72 e0       	ldi	r23, 0x02	; 2
 4ba:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>


}
 4be:	1f 91       	pop	r17
 4c0:	08 95       	ret

000004c2 <UART_putnum>:


void UART_putnum(uint8_t com, uint8_t num){
 4c2:	38 2f       	mov	r19, r24
 4c4:	26 2f       	mov	r18, r22

    if(num >= 100){
 4c6:	64 36       	cpi	r22, 0x64	; 100
 4c8:	b0 f0       	brcs	.+44     	; 0x4f6 <UART_putnum+0x34>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 4ca:	e8 2f       	mov	r30, r24
 4cc:	f0 e0       	ldi	r31, 0x00	; 0
 4ce:	ee 0f       	add	r30, r30
 4d0:	ff 1f       	adc	r31, r31
 4d2:	e0 5c       	subi	r30, 0xC0	; 192
 4d4:	fd 4f       	sbci	r31, 0xFD	; 253
 4d6:	01 90       	ld	r0, Z+
 4d8:	f0 81       	ld	r31, Z
 4da:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 4dc:	80 81       	ld	r24, Z
 4de:	85 ff       	sbrs	r24, 5
 4e0:	fd cf       	rjmp	.-6      	; 0x4dc <UART_putnum+0x1a>


void UART_putnum(uint8_t com, uint8_t num){

    if(num >= 100){
        UART_putchar(com, '0'+(num/100));
 4e2:	82 2f       	mov	r24, r18
 4e4:	64 e6       	ldi	r22, 0x64	; 100
 4e6:	0e 94 bc 03 	call	0x778	; 0x778 <__udivmodqi4>
 4ea:	80 5d       	subi	r24, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 4ec:	86 83       	std	Z+6, r24	; 0x06

void UART_putnum(uint8_t com, uint8_t num){

    if(num >= 100){
        UART_putchar(com, '0'+(num/100));
        num%=100;
 4ee:	82 2f       	mov	r24, r18
 4f0:	0e 94 bc 03 	call	0x778	; 0x778 <__udivmodqi4>
 4f4:	29 2f       	mov	r18, r25
    }
    if(num>=10){
 4f6:	2a 30       	cpi	r18, 0x0A	; 10
 4f8:	b0 f0       	brcs	.+44     	; 0x526 <UART_putnum+0x64>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 4fa:	e3 2f       	mov	r30, r19
 4fc:	f0 e0       	ldi	r31, 0x00	; 0
 4fe:	ee 0f       	add	r30, r30
 500:	ff 1f       	adc	r31, r31
 502:	e0 5c       	subi	r30, 0xC0	; 192
 504:	fd 4f       	sbci	r31, 0xFD	; 253
 506:	01 90       	ld	r0, Z+
 508:	f0 81       	ld	r31, Z
 50a:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 50c:	80 81       	ld	r24, Z
 50e:	85 ff       	sbrs	r24, 5
 510:	fd cf       	rjmp	.-6      	; 0x50c <UART_putnum+0x4a>
    if(num >= 100){
        UART_putchar(com, '0'+(num/100));
        num%=100;
    }
    if(num>=10){
        UART_putchar(com, '0'+(num/10));
 512:	82 2f       	mov	r24, r18
 514:	6a e0       	ldi	r22, 0x0A	; 10
 516:	0e 94 bc 03 	call	0x778	; 0x778 <__udivmodqi4>
 51a:	80 5d       	subi	r24, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 51c:	86 83       	std	Z+6, r24	; 0x06
        UART_putchar(com, '0'+(num/100));
        num%=100;
    }
    if(num>=10){
        UART_putchar(com, '0'+(num/10));
        num%=10;
 51e:	82 2f       	mov	r24, r18
 520:	0e 94 bc 03 	call	0x778	; 0x778 <__udivmodqi4>
 524:	29 2f       	mov	r18, r25
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 526:	e3 2f       	mov	r30, r19
 528:	f0 e0       	ldi	r31, 0x00	; 0
 52a:	ee 0f       	add	r30, r30
 52c:	ff 1f       	adc	r31, r31
 52e:	e0 5c       	subi	r30, 0xC0	; 192
 530:	fd 4f       	sbci	r31, 0xFD	; 253
 532:	01 90       	ld	r0, Z+
 534:	f0 81       	ld	r31, Z
 536:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 538:	80 81       	ld	r24, Z
 53a:	85 ff       	sbrs	r24, 5
 53c:	fd cf       	rjmp	.-6      	; 0x538 <UART_putnum+0x76>
    if(num>=10){
        UART_putchar(com, '0'+(num/10));
        num%=10;
    }

    UART_putchar(com,'0'+num);
 53e:	20 5d       	subi	r18, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 540:	26 83       	std	Z+6, r18	; 0x06
        num%=10;
    }

    UART_putchar(com,'0'+num);

}
 542:	08 95       	ret

00000544 <UART_gotoxy>:


UART_gotoxy(uint8_t com, uint8_t x, uint8_t y){
 544:	ff 92       	push	r15
 546:	0f 93       	push	r16
 548:	1f 93       	push	r17
 54a:	cf 93       	push	r28
 54c:	df 93       	push	r29
 54e:	08 2f       	mov	r16, r24
 550:	f6 2e       	mov	r15, r22
 552:	14 2f       	mov	r17, r20

    UART_puts(com,"\x1B["); //inicio de la secuencia de esapce
 554:	6c e2       	ldi	r22, 0x2C	; 44
 556:	72 e0       	ldi	r23, 0x02	; 2
 558:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>

    UART_putnum(com,y+1); //convertir a caracter
 55c:	1f 5f       	subi	r17, 0xFF	; 255
 55e:	80 2f       	mov	r24, r16
 560:	61 2f       	mov	r22, r17
 562:	0e 94 61 02 	call	0x4c2	; 0x4c2 <UART_putnum>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 566:	c0 2f       	mov	r28, r16
 568:	d0 e0       	ldi	r29, 0x00	; 0
 56a:	fe 01       	movw	r30, r28
 56c:	ee 0f       	add	r30, r30
 56e:	ff 1f       	adc	r31, r31
 570:	e0 5c       	subi	r30, 0xC0	; 192
 572:	fd 4f       	sbci	r31, 0xFD	; 253
 574:	01 90       	ld	r0, Z+
 576:	f0 81       	ld	r31, Z
 578:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 57a:	80 81       	ld	r24, Z
 57c:	85 ff       	sbrs	r24, 5
 57e:	fd cf       	rjmp	.-6      	; 0x57a <UART_gotoxy+0x36>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 580:	8b e3       	ldi	r24, 0x3B	; 59
 582:	86 83       	std	Z+6, r24	; 0x06

    UART_puts(com,"\x1B["); //inicio de la secuencia de esapce

    UART_putnum(com,y+1); //convertir a caracter
    UART_putchar(com,';');
    UART_putnum(com,x+1);
 584:	f3 94       	inc	r15
 586:	80 2f       	mov	r24, r16
 588:	6f 2d       	mov	r22, r15
 58a:	0e 94 61 02 	call	0x4c2	; 0x4c2 <UART_putnum>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 58e:	cc 0f       	add	r28, r28
 590:	dd 1f       	adc	r29, r29
 592:	c0 5c       	subi	r28, 0xC0	; 192
 594:	dd 4f       	sbci	r29, 0xFD	; 253
 596:	e8 81       	ld	r30, Y
 598:	f9 81       	ldd	r31, Y+1	; 0x01
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 59a:	80 81       	ld	r24, Z
 59c:	85 ff       	sbrs	r24, 5
 59e:	fd cf       	rjmp	.-6      	; 0x59a <UART_gotoxy+0x56>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 5a0:	88 e4       	ldi	r24, 0x48	; 72
 5a2:	86 83       	std	Z+6, r24	; 0x06
    UART_putnum(com,y+1); //convertir a caracter
    UART_putchar(com,';');
    UART_putnum(com,x+1);
    UART_putchar(com,'H'); //final de la secuencia

}
 5a4:	df 91       	pop	r29
 5a6:	cf 91       	pop	r28
 5a8:	1f 91       	pop	r17
 5aa:	0f 91       	pop	r16
 5ac:	ff 90       	pop	r15
 5ae:	08 95       	ret

000005b0 <UART_setColor>:





UART_setColor(uint8_t com, uint8_t color){
 5b0:	0f 93       	push	r16
 5b2:	1f 93       	push	r17
 5b4:	18 2f       	mov	r17, r24
 5b6:	06 2f       	mov	r16, r22


    UART_puts(com,"\x1B["); //incio del comando espace
 5b8:	6c e2       	ldi	r22, 0x2C	; 44
 5ba:	72 e0       	ldi	r23, 0x02	; 2
 5bc:	0e 94 8a 01 	call	0x314	; 0x314 <UART_puts>
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 5c0:	a1 2f       	mov	r26, r17
 5c2:	b0 e0       	ldi	r27, 0x00	; 0
 5c4:	fd 01       	movw	r30, r26
 5c6:	ee 0f       	add	r30, r30
 5c8:	ff 1f       	adc	r31, r31
 5ca:	e0 5c       	subi	r30, 0xC0	; 192
 5cc:	fd 4f       	sbci	r31, 0xFD	; 253
 5ce:	01 90       	ld	r0, Z+
 5d0:	f0 81       	ld	r31, Z
 5d2:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 5d4:	80 81       	ld	r24, Z
 5d6:	85 ff       	sbrs	r24, 5
 5d8:	fd cf       	rjmp	.-6      	; 0x5d4 <UART_setColor+0x24>

UART_setColor(uint8_t com, uint8_t color){


    UART_puts(com,"\x1B["); //incio del comando espace
    UART_putchar(com, '0'+(color/10));
 5da:	80 2f       	mov	r24, r16
 5dc:	6a e0       	ldi	r22, 0x0A	; 10
 5de:	0e 94 bc 03 	call	0x778	; 0x778 <__udivmodqi4>
 5e2:	80 5d       	subi	r24, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 5e4:	86 83       	std	Z+6, r24	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 5e6:	fd 01       	movw	r30, r26
 5e8:	ee 0f       	add	r30, r30
 5ea:	ff 1f       	adc	r31, r31
 5ec:	e0 5c       	subi	r30, 0xC0	; 192
 5ee:	fd 4f       	sbci	r31, 0xFD	; 253
 5f0:	01 90       	ld	r0, Z+
 5f2:	f0 81       	ld	r31, Z
 5f4:	e0 2d       	mov	r30, r0
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 5f6:	80 81       	ld	r24, Z
 5f8:	85 ff       	sbrs	r24, 5
 5fa:	fd cf       	rjmp	.-6      	; 0x5f6 <UART_setColor+0x46>
UART_setColor(uint8_t com, uint8_t color){


    UART_puts(com,"\x1B["); //incio del comando espace
    UART_putchar(com, '0'+(color/10));
    UART_putchar(com,'0'+(color%10));
 5fc:	80 2f       	mov	r24, r16
 5fe:	6a e0       	ldi	r22, 0x0A	; 10
 600:	0e 94 bc 03 	call	0x778	; 0x778 <__udivmodqi4>
 604:	90 5d       	subi	r25, 0xD0	; 208

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 606:	96 83       	std	Z+6, r25	; 0x06
	//que el registro esta vacio,

	//entonces el ciclo va a espear para cunado este se vacie por completo
	//lo que hace es esperar mientras haya datos dentro del buffer

	UART_reg_t *myUART = UART_offset[com];
 608:	aa 0f       	add	r26, r26
 60a:	bb 1f       	adc	r27, r27
 60c:	a0 5c       	subi	r26, 0xC0	; 192
 60e:	bd 4f       	sbci	r27, 0xFD	; 253
 610:	ed 91       	ld	r30, X+
 612:	fc 91       	ld	r31, X
    uint8_t udre_bit = (com == 0) ? UDRE0 :
                      (com == 1) ? UDRE1 :
                      (com == 2) ? UDRE2 : UDRE3;

    //va a esperar hasta que se vacie por completo
	while (!(myUART->UCSRA & (1 << udre_bit)));
 614:	80 81       	ld	r24, Z
 616:	85 ff       	sbrs	r24, 5
 618:	fd cf       	rjmp	.-6      	; 0x614 <UART_setColor+0x64>
		; //espera a que el periferico este vacio

	myUART->UDR= data;
 61a:	8d e6       	ldi	r24, 0x6D	; 109
 61c:	86 83       	std	Z+6, r24	; 0x06

    UART_puts(com,"\x1B["); //incio del comando espace
    UART_putchar(com, '0'+(color/10));
    UART_putchar(com,'0'+(color%10));
    UART_putchar(com,'m'); //final del comando
 }
 61e:	1f 91       	pop	r17
 620:	0f 91       	pop	r16
 622:	08 95       	ret

00000624 <itoa>:




// Utils
void itoa(uint16_t number, char* str, uint8_t base){
 624:	0f 93       	push	r16
 626:	1f 93       	push	r17
 628:	df 93       	push	r29
 62a:	cf 93       	push	r28
 62c:	cd b7       	in	r28, 0x3d	; 61
 62e:	de b7       	in	r29, 0x3e	; 62
 630:	a1 97       	sbiw	r28, 0x21	; 33
 632:	0f b6       	in	r0, 0x3f	; 63
 634:	f8 94       	cli
 636:	de bf       	out	0x3e, r29	; 62
 638:	0f be       	out	0x3f, r0	; 63
 63a:	cd bf       	out	0x3d, r28	; 61


    char *aux= str;

    if(base == 16){
 63c:	40 31       	cpi	r20, 0x10	; 16
 63e:	a1 f5       	brne	.+104    	; 0x6a8 <itoa+0x84>

        //asignamos un arreglo con las representaciones de los numero HEX en ASCI
        char hex[] = "0123456789ABCDEF";
 640:	de 01       	movw	r26, r28
 642:	51 96       	adiw	r26, 0x11	; 17
 644:	ef e2       	ldi	r30, 0x2F	; 47
 646:	f2 e0       	ldi	r31, 0x02	; 2
 648:	21 e1       	ldi	r18, 0x11	; 17
 64a:	01 90       	ld	r0, Z+
 64c:	0d 92       	st	X+, r0
 64e:	21 50       	subi	r18, 0x01	; 1
 650:	e1 f7       	brne	.-8      	; 0x64a <itoa+0x26>
        uint8_t index = 0;
        uint16_t temp = number; //hacemos un backup de number para trbajar con el y no pereder el valor original

        // Manejar el caso cuando el número es 0
        if (temp == 0) {
 652:	00 97       	sbiw	r24, 0x00	; 0
 654:	69 f1       	breq	.+90     	; 0x6b0 <itoa+0x8c>
            aux[index++] = '0';
            aux[index] = '\0';
            return;
 656:	9c 01       	movw	r18, r24
 658:	90 e0       	ldi	r25, 0x00	; 0
        //asi como un idx el cual controla cunatos digitiso tiene el numero
        char buffer[16];
        uint8_t buf_idx = 0;

        while (temp > 0) {
            buffer[buf_idx++] = hex[temp % base];
 65a:	ae 01       	movw	r20, r28
 65c:	4f 5f       	subi	r20, 0xFF	; 255
 65e:	5f 4f       	sbci	r21, 0xFF	; 255
 660:	8e 01       	movw	r16, r28
 662:	0f 5e       	subi	r16, 0xEF	; 239
 664:	1f 4f       	sbci	r17, 0xFF	; 255
 666:	fa 01       	movw	r30, r20
 668:	e9 0f       	add	r30, r25
 66a:	f1 1d       	adc	r31, r1
 66c:	d9 01       	movw	r26, r18
 66e:	af 70       	andi	r26, 0x0F	; 15
 670:	b0 70       	andi	r27, 0x00	; 0
 672:	a0 0f       	add	r26, r16
 674:	b1 1f       	adc	r27, r17
 676:	8c 91       	ld	r24, X
 678:	80 83       	st	Z, r24
 67a:	9f 5f       	subi	r25, 0xFF	; 255
            temp /= base;
 67c:	f4 e0       	ldi	r31, 0x04	; 4
 67e:	36 95       	lsr	r19
 680:	27 95       	ror	r18
 682:	fa 95       	dec	r31
 684:	e1 f7       	brne	.-8      	; 0x67e <itoa+0x5a>

        //asi como un idx el cual controla cunatos digitiso tiene el numero
        char buffer[16];
        uint8_t buf_idx = 0;

        while (temp > 0) {
 686:	21 15       	cp	r18, r1
 688:	31 05       	cpc	r19, r1
 68a:	69 f7       	brne	.-38     	; 0x666 <itoa+0x42>
 68c:	fa 01       	movw	r30, r20
 68e:	e9 0f       	add	r30, r25
 690:	f1 1d       	adc	r31, r1
 692:	db 01       	movw	r26, r22
 694:	02 c0       	rjmp	.+4      	; 0x69a <itoa+0x76>

            pero 523 en HEX es -  20B, por lo uqe haceos como si fuera una pila si lo podemos ver asi
        */
        // Invertir la cadena
        for (int i = buf_idx - 1; i >= 0; i--) {
            aux[index++] = buffer[i];
 696:	80 81       	ld	r24, Z
 698:	8d 93       	st	X+, r24
 69a:	31 97       	sbiw	r30, 0x01	; 1
            523 se puede diviir 3 veces por 16 el cual da en la primea 11 - 0 - 2

            pero 523 en HEX es -  20B, por lo uqe haceos como si fuera una pila si lo podemos ver asi
        */
        // Invertir la cadena
        for (int i = buf_idx - 1; i >= 0; i--) {
 69c:	ec 17       	cp	r30, r28
 69e:	fd 07       	cpc	r31, r29
 6a0:	d1 f7       	brne	.-12     	; 0x696 <itoa+0x72>
            aux[index++] = buffer[i];
        }
        aux[index] = '\0'; // Terminar con nulo
 6a2:	69 0f       	add	r22, r25
 6a4:	71 1d       	adc	r23, r1
 6a6:	3d c0       	rjmp	.+122    	; 0x722 <itoa+0xfe>


    }


    else if(base == 2){
 6a8:	42 30       	cpi	r20, 0x02	; 2
 6aa:	e9 f5       	brne	.+122    	; 0x726 <itoa+0x102>

        //con el binario es un poco mas sencillo pero el proceso es el mismo

        //verificamos si el numero es 0 entonces volvemos a mandar le 0 no tiene caso que
        //se pierda tiempo en un proceso que incluso nos puede dar error
        if(number ==0){
 6ac:	00 97       	sbiw	r24, 0x00	; 0
 6ae:	29 f4       	brne	.+10     	; 0x6ba <itoa+0x96>

            aux[index++] = '0';
 6b0:	80 e3       	ldi	r24, 0x30	; 48
 6b2:	fb 01       	movw	r30, r22
 6b4:	80 83       	st	Z, r24
            aux[index] = '\0';
 6b6:	11 82       	std	Z+1, r1	; 0x01
 6b8:	36 c0       	rjmp	.+108    	; 0x726 <itoa+0x102>
            return;
 6ba:	20 e0       	ldi	r18, 0x00	; 0



        while(temp > 0){

            buffer[buf_idx++]= (temp%2)?'1':'0';
 6bc:	ae 01       	movw	r20, r28
 6be:	4f 5e       	subi	r20, 0xEF	; 239
 6c0:	5f 4f       	sbci	r21, 0xFF	; 255
 6c2:	80 fd       	sbrc	r24, 0
 6c4:	02 c0       	rjmp	.+4      	; 0x6ca <itoa+0xa6>
 6c6:	30 e3       	ldi	r19, 0x30	; 48
 6c8:	01 c0       	rjmp	.+2      	; 0x6cc <itoa+0xa8>
 6ca:	31 e3       	ldi	r19, 0x31	; 49
 6cc:	fa 01       	movw	r30, r20
 6ce:	e2 0f       	add	r30, r18
 6d0:	f1 1d       	adc	r31, r1
 6d2:	30 83       	st	Z, r19
 6d4:	2f 5f       	subi	r18, 0xFF	; 255
            temp/=2;
 6d6:	96 95       	lsr	r25
 6d8:	87 95       	ror	r24
            return;
        }



        while(temp > 0){
 6da:	00 97       	sbiw	r24, 0x00	; 0
 6dc:	91 f7       	brne	.-28     	; 0x6c2 <itoa+0x9e>
 6de:	06 c0       	rjmp	.+12     	; 0x6ec <itoa+0xc8>


        //rellenar con ceros a la izqueirda

        while(buf_idx < 16){
            buffer[buf_idx++]= '0';
 6e0:	fc 01       	movw	r30, r24
 6e2:	e2 0f       	add	r30, r18
 6e4:	f1 1d       	adc	r31, r1
 6e6:	30 83       	st	Z, r19
 6e8:	2f 5f       	subi	r18, 0xFF	; 255
 6ea:	03 c0       	rjmp	.+6      	; 0x6f2 <itoa+0xce>
 6ec:	ce 01       	movw	r24, r28
 6ee:	41 96       	adiw	r24, 0x11	; 17
 6f0:	30 e3       	ldi	r19, 0x30	; 48
        }


        //rellenar con ceros a la izqueirda

        while(buf_idx < 16){
 6f2:	20 31       	cpi	r18, 0x10	; 16
 6f4:	a8 f3       	brcs	.-22     	; 0x6e0 <itoa+0xbc>
            buffer[buf_idx++]= '0';
        }

        index=0;

        for(int8_t i = buf_idx-1 ; i >= 0 ; i--){
 6f6:	42 2f       	mov	r20, r18
 6f8:	41 50       	subi	r20, 0x01	; 1
 6fa:	a4 2f       	mov	r26, r20
 6fc:	bb 27       	eor	r27, r27
 6fe:	a7 fd       	sbrc	r26, 7
 700:	b0 95       	com	r27
 702:	a8 0f       	add	r26, r24
 704:	b9 1f       	adc	r27, r25
 706:	56 2f       	mov	r21, r22
 708:	cb 01       	movw	r24, r22
 70a:	fc 01       	movw	r30, r24
 70c:	04 c0       	rjmp	.+8      	; 0x716 <itoa+0xf2>
            aux[index++] = buffer[i];
 70e:	8c 91       	ld	r24, X
 710:	81 93       	st	Z+, r24
            buffer[buf_idx++]= '0';
        }

        index=0;

        for(int8_t i = buf_idx-1 ; i >= 0 ; i--){
 712:	41 50       	subi	r20, 0x01	; 1
 714:	11 97       	sbiw	r26, 0x01	; 1
 716:	8e 2f       	mov	r24, r30
 718:	85 1b       	sub	r24, r21
 71a:	47 ff       	sbrs	r20, 7
 71c:	f8 cf       	rjmp	.-16     	; 0x70e <itoa+0xea>
            aux[index++] = buffer[i];
        }

        aux[index]='\0';
 71e:	68 0f       	add	r22, r24
 720:	71 1d       	adc	r23, r1
 722:	fb 01       	movw	r30, r22
 724:	10 82       	st	Z, r1


    }

}
 726:	a1 96       	adiw	r28, 0x21	; 33
 728:	0f b6       	in	r0, 0x3f	; 63
 72a:	f8 94       	cli
 72c:	de bf       	out	0x3e, r29	; 62
 72e:	0f be       	out	0x3f, r0	; 63
 730:	cd bf       	out	0x3d, r28	; 61
 732:	cf 91       	pop	r28
 734:	df 91       	pop	r29
 736:	1f 91       	pop	r17
 738:	0f 91       	pop	r16
 73a:	08 95       	ret

0000073c <atoi>:



uint16_t atoi(char *str) {
 73c:	fc 01       	movw	r30, r24
 73e:	20 e0       	ldi	r18, 0x00	; 0
 740:	30 e0       	ldi	r19, 0x00	; 0
 742:	15 c0       	rjmp	.+42     	; 0x76e <atoi+0x32>
    uint16_t result = 0;
    while (*str != '\0') {
        if (*str >= '0' && *str <= '9') {
 744:	84 2f       	mov	r24, r20
 746:	80 53       	subi	r24, 0x30	; 48
 748:	8a 30       	cpi	r24, 0x0A	; 10
 74a:	80 f4       	brcc	.+32     	; 0x76c <atoi+0x30>
            result = result * 10 + (*str - '0');
 74c:	c9 01       	movw	r24, r18
 74e:	b3 e0       	ldi	r27, 0x03	; 3
 750:	88 0f       	add	r24, r24
 752:	99 1f       	adc	r25, r25
 754:	ba 95       	dec	r27
 756:	e1 f7       	brne	.-8      	; 0x750 <atoi+0x14>
 758:	22 0f       	add	r18, r18
 75a:	33 1f       	adc	r19, r19
 75c:	82 0f       	add	r24, r18
 75e:	93 1f       	adc	r25, r19
 760:	24 2f       	mov	r18, r20
 762:	30 e0       	ldi	r19, 0x00	; 0
 764:	20 53       	subi	r18, 0x30	; 48
 766:	30 40       	sbci	r19, 0x00	; 0
 768:	28 0f       	add	r18, r24
 76a:	39 1f       	adc	r19, r25
        }
        str++;
 76c:	31 96       	adiw	r30, 0x01	; 1



uint16_t atoi(char *str) {
    uint16_t result = 0;
    while (*str != '\0') {
 76e:	40 81       	ld	r20, Z
 770:	44 23       	and	r20, r20
 772:	41 f7       	brne	.-48     	; 0x744 <atoi+0x8>
            result = result * 10 + (*str - '0');
        }
        str++;
    }
    return result;
}
 774:	c9 01       	movw	r24, r18
 776:	08 95       	ret

00000778 <__udivmodqi4>:
 778:	99 1b       	sub	r25, r25
 77a:	79 e0       	ldi	r23, 0x09	; 9
 77c:	04 c0       	rjmp	.+8      	; 0x786 <__udivmodqi4_ep>

0000077e <__udivmodqi4_loop>:
 77e:	99 1f       	adc	r25, r25
 780:	96 17       	cp	r25, r22
 782:	08 f0       	brcs	.+2      	; 0x786 <__udivmodqi4_ep>
 784:	96 1b       	sub	r25, r22

00000786 <__udivmodqi4_ep>:
 786:	88 1f       	adc	r24, r24
 788:	7a 95       	dec	r23
 78a:	c9 f7       	brne	.-14     	; 0x77e <__udivmodqi4_loop>
 78c:	80 95       	com	r24
 78e:	08 95       	ret

00000790 <__udivmodsi4>:
 790:	a1 e2       	ldi	r26, 0x21	; 33
 792:	1a 2e       	mov	r1, r26
 794:	aa 1b       	sub	r26, r26
 796:	bb 1b       	sub	r27, r27
 798:	fd 01       	movw	r30, r26
 79a:	0d c0       	rjmp	.+26     	; 0x7b6 <__udivmodsi4_ep>

0000079c <__udivmodsi4_loop>:
 79c:	aa 1f       	adc	r26, r26
 79e:	bb 1f       	adc	r27, r27
 7a0:	ee 1f       	adc	r30, r30
 7a2:	ff 1f       	adc	r31, r31
 7a4:	a2 17       	cp	r26, r18
 7a6:	b3 07       	cpc	r27, r19
 7a8:	e4 07       	cpc	r30, r20
 7aa:	f5 07       	cpc	r31, r21
 7ac:	20 f0       	brcs	.+8      	; 0x7b6 <__udivmodsi4_ep>
 7ae:	a2 1b       	sub	r26, r18
 7b0:	b3 0b       	sbc	r27, r19
 7b2:	e4 0b       	sbc	r30, r20
 7b4:	f5 0b       	sbc	r31, r21

000007b6 <__udivmodsi4_ep>:
 7b6:	66 1f       	adc	r22, r22
 7b8:	77 1f       	adc	r23, r23
 7ba:	88 1f       	adc	r24, r24
 7bc:	99 1f       	adc	r25, r25
 7be:	1a 94       	dec	r1
 7c0:	69 f7       	brne	.-38     	; 0x79c <__udivmodsi4_loop>
 7c2:	60 95       	com	r22
 7c4:	70 95       	com	r23
 7c6:	80 95       	com	r24
 7c8:	90 95       	com	r25
 7ca:	9b 01       	movw	r18, r22
 7cc:	ac 01       	movw	r20, r24
 7ce:	bd 01       	movw	r22, r26
 7d0:	cf 01       	movw	r24, r30
 7d2:	08 95       	ret

000007d4 <_exit>:
 7d4:	f8 94       	cli

000007d6 <__stop_program>:
 7d6:	ff cf       	rjmp	.-2      	; 0x7d6 <__stop_program>
