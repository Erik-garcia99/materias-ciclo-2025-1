
practica5.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000014  00800200  000004cc  00000560  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000004cc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000006  00800214  00800214  00000574  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000578  2**3
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000000e0  00000000  00000000  000005b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000043b  00000000  00000000  00000698  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000001aa  00000000  00000000  00000ad3  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000415  00000000  00000000  00000c7d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000000c0  00000000  00000000  00001094  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000259  00000000  00000000  00001154  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000110  00000000  00000000  000013ad  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	ec ec       	ldi	r30, 0xCC	; 204
  fc:	f4 e0       	ldi	r31, 0x04	; 4
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a4 31       	cpi	r26, 0x14	; 20
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	12 e0       	ldi	r17, 0x02	; 2
 110:	a4 e1       	ldi	r26, 0x14	; 20
 112:	b2 e0       	ldi	r27, 0x02	; 2
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	aa 31       	cpi	r26, 0x1A	; 26
 11a:	b1 07       	cpc	r27, r17
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	0e 94 98 01 	call	0x330	; 0x330 <main>
 122:	0c 94 64 02 	jmp	0x4c8	; 0x4c8 <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <InitPorts>:
     ~
     0111 1111 -> dejo pasar a los 1 y los ceros de vuelven ceros, se mantienen
    */

    //PF7 como entrada - entrada es 0
    DDRF &= ~(1<<PF7); //configruacmos pf7 como entrada
 12a:	87 98       	cbi	0x10, 7	; 16
    PORTF |= (1<<PF7); // activamos PULL-UP
 12c:	8f 9a       	sbi	0x11, 7	; 17

    DDRF |=(1<<PF6); //activamos a PF6 como salida
 12e:	86 9a       	sbi	0x10, 6	; 16
    PORTF &=~(1<<PF6); //sacamos el 0
 130:	8e 98       	cbi	0x11, 6	; 17





}
 132:	08 95       	ret

00000134 <_endCount_>:



void _endCount_(void){

    DDRF &=0xF0;
 134:	80 b3       	in	r24, 0x10	; 16
 136:	80 7f       	andi	r24, 0xF0	; 240
 138:	80 bb       	out	0x10, r24	; 16
    PORTF &= 0xF0;
 13a:	81 b3       	in	r24, 0x11	; 17
 13c:	80 7f       	andi	r24, 0xF0	; 240
 13e:	81 bb       	out	0x11, r24	; 17

}
 140:	08 95       	ret

00000142 <__HIGH_NIBBLE__>:
void __HIGH_NIBBLE__(void){


    static volatile uint8_t idx = 4;

    DDRF = _CONF_DDR[idx] | (DDRF & 0xF0);
 142:	90 91 10 02 	lds	r25, 0x0210
 146:	80 b3       	in	r24, 0x10	; 16
 148:	e0 e0       	ldi	r30, 0x00	; 0
 14a:	f2 e0       	ldi	r31, 0x02	; 2
 14c:	e9 0f       	add	r30, r25
 14e:	f1 1d       	adc	r31, r1
 150:	80 7f       	andi	r24, 0xF0	; 240
 152:	90 81       	ld	r25, Z
 154:	89 2b       	or	r24, r25
 156:	80 bb       	out	0x10, r24	; 16
    PORTF = _CONF_PORT[idx] | (PORTF & 0xF0);
 158:	90 91 10 02 	lds	r25, 0x0210
 15c:	81 b3       	in	r24, 0x11	; 17
 15e:	e8 e0       	ldi	r30, 0x08	; 8
 160:	f2 e0       	ldi	r31, 0x02	; 2
 162:	e9 0f       	add	r30, r25
 164:	f1 1d       	adc	r31, r1
 166:	80 7f       	andi	r24, 0xF0	; 240
 168:	90 81       	ld	r25, Z
 16a:	89 2b       	or	r24, r25
 16c:	81 bb       	out	0x11, r24	; 17
    delay(1);
 16e:	81 e0       	ldi	r24, 0x01	; 1
 170:	90 e0       	ldi	r25, 0x00	; 0
 172:	0e 94 17 02 	call	0x42e	; 0x42e <delay>

    idx = 4 + ((idx + 1) % 4);
 176:	80 91 10 02 	lds	r24, 0x0210
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	01 96       	adiw	r24, 0x01	; 1
 17e:	83 70       	andi	r24, 0x03	; 3
 180:	90 70       	andi	r25, 0x00	; 0
 182:	8c 5f       	subi	r24, 0xFC	; 252
 184:	80 93 10 02 	sts	0x0210, r24
}
 188:	08 95       	ret

0000018a <__LOW_NIBBLE__>:

void __LOW_NIBBLE__(void){

    static volatile uint8_t idx =0;

    DDRF = _CONF_DDR[idx] | (DDRF & 0xF0);
 18a:	90 91 14 02 	lds	r25, 0x0214
 18e:	80 b3       	in	r24, 0x10	; 16
 190:	e0 e0       	ldi	r30, 0x00	; 0
 192:	f2 e0       	ldi	r31, 0x02	; 2
 194:	e9 0f       	add	r30, r25
 196:	f1 1d       	adc	r31, r1
 198:	80 7f       	andi	r24, 0xF0	; 240
 19a:	90 81       	ld	r25, Z
 19c:	89 2b       	or	r24, r25
 19e:	80 bb       	out	0x10, r24	; 16
    PORTF = _CONF_PORT[idx] | (PORTF & 0xF0);
 1a0:	90 91 14 02 	lds	r25, 0x0214
 1a4:	81 b3       	in	r24, 0x11	; 17
 1a6:	e8 e0       	ldi	r30, 0x08	; 8
 1a8:	f2 e0       	ldi	r31, 0x02	; 2
 1aa:	e9 0f       	add	r30, r25
 1ac:	f1 1d       	adc	r31, r1
 1ae:	80 7f       	andi	r24, 0xF0	; 240
 1b0:	90 81       	ld	r25, Z
 1b2:	89 2b       	or	r24, r25
 1b4:	81 bb       	out	0x11, r24	; 17
    delay(1);
 1b6:	81 e0       	ldi	r24, 0x01	; 1
 1b8:	90 e0       	ldi	r25, 0x00	; 0
 1ba:	0e 94 17 02 	call	0x42e	; 0x42e <delay>

    idx = (idx + 1)%4;
 1be:	80 91 14 02 	lds	r24, 0x0214
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	01 96       	adiw	r24, 0x01	; 1
 1c6:	83 70       	andi	r24, 0x03	; 3
 1c8:	90 70       	andi	r25, 0x00	; 0
 1ca:	80 93 14 02 	sts	0x0214, r24

}
 1ce:	08 95       	ret

000001d0 <_youLoose_>:
    //7 6 5 4  3 2 1 0


    for(uint8_t idx =0 ; idx< 4 ; idx++){

        __LOW_NIBBLE__();
 1d0:	0e 94 c5 00 	call	0x18a	; 0x18a <__LOW_NIBBLE__>
 1d4:	0e 94 c5 00 	call	0x18a	; 0x18a <__LOW_NIBBLE__>
 1d8:	0e 94 c5 00 	call	0x18a	; 0x18a <__LOW_NIBBLE__>
 1dc:	0e 94 c5 00 	call	0x18a	; 0x18a <__LOW_NIBBLE__>



void _endCount_(void){

    DDRF &=0xF0;
 1e0:	80 b3       	in	r24, 0x10	; 16
 1e2:	80 7f       	andi	r24, 0xF0	; 240
 1e4:	80 bb       	out	0x10, r24	; 16
    PORTF &= 0xF0;
 1e6:	81 b3       	in	r24, 0x11	; 17
 1e8:	80 7f       	andi	r24, 0xF0	; 240
 1ea:	81 bb       	out	0x11, r24	; 17
        __LOW_NIBBLE__();
    }

    _endCount_();

    delay(500);
 1ec:	84 ef       	ldi	r24, 0xF4	; 244
 1ee:	91 e0       	ldi	r25, 0x01	; 1
 1f0:	0e 94 17 02 	call	0x42e	; 0x42e <delay>



    for(uint8_t idx =0 ; idx< 4; idx++){

        __HIGH_NIBBLE__();
 1f4:	0e 94 a1 00 	call	0x142	; 0x142 <__HIGH_NIBBLE__>
 1f8:	0e 94 a1 00 	call	0x142	; 0x142 <__HIGH_NIBBLE__>
 1fc:	0e 94 a1 00 	call	0x142	; 0x142 <__HIGH_NIBBLE__>
 200:	0e 94 a1 00 	call	0x142	; 0x142 <__HIGH_NIBBLE__>



void _endCount_(void){

    DDRF &=0xF0;
 204:	80 b3       	in	r24, 0x10	; 16
 206:	80 7f       	andi	r24, 0xF0	; 240
 208:	80 bb       	out	0x10, r24	; 16
    PORTF &= 0xF0;
 20a:	81 b3       	in	r24, 0x11	; 17
 20c:	80 7f       	andi	r24, 0xF0	; 240
 20e:	81 bb       	out	0x11, r24	; 17

        __HIGH_NIBBLE__();

    }
    _endCount_();
    delay(500);
 210:	84 ef       	ldi	r24, 0xF4	; 244
 212:	91 e0       	ldi	r25, 0x01	; 1
 214:	0e 94 17 02 	call	0x42e	; 0x42e <delay>


}
 218:	08 95       	ret

0000021a <_waitState_>:
void _waitState_(void){

    static volatile uint8_t indice=0; // static para mantenre el valor entre entrada y salida de la funcion y no quiero
    //que se optimice ya que estara cambiando constantemente

    DDRF = _CONF_DDR[indice];
 21a:	80 91 15 02 	lds	r24, 0x0215
 21e:	e0 e0       	ldi	r30, 0x00	; 0
 220:	f2 e0       	ldi	r31, 0x02	; 2
 222:	e8 0f       	add	r30, r24
 224:	f1 1d       	adc	r31, r1
 226:	80 81       	ld	r24, Z
 228:	80 bb       	out	0x10, r24	; 16
    PORTF= _CONF_PORT[indice];
 22a:	80 91 15 02 	lds	r24, 0x0215
 22e:	e8 e0       	ldi	r30, 0x08	; 8
 230:	f2 e0       	ldi	r31, 0x02	; 2
 232:	e8 0f       	add	r30, r24
 234:	f1 1d       	adc	r31, r1
 236:	80 81       	ld	r24, Z
 238:	81 bb       	out	0x11, r24	; 17
    delay(1);
 23a:	81 e0       	ldi	r24, 0x01	; 1
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	0e 94 17 02 	call	0x42e	; 0x42e <delay>

    indice= (indice+1) % 8;
 242:	80 91 15 02 	lds	r24, 0x0215
 246:	90 e0       	ldi	r25, 0x00	; 0
 248:	01 96       	adiw	r24, 0x01	; 1
 24a:	87 70       	andi	r24, 0x07	; 7
 24c:	90 70       	andi	r25, 0x00	; 0
 24e:	80 93 15 02 	sts	0x0215, r24

}
 252:	08 95       	ret

00000254 <_youWin_>:

    idx = 4 + ((idx + 1) % 4);
}


void _youWin_(void){
 254:	1f 93       	push	r17
 256:	10 e0       	ldi	r17, 0x00	; 0


    for(uint8_t idx=0; idx< 8 ; idx++){

        _waitState_();
 258:	0e 94 0d 01 	call	0x21a	; 0x21a <_waitState_>


void _youWin_(void){


    for(uint8_t idx=0; idx< 8 ; idx++){
 25c:	1f 5f       	subi	r17, 0xFF	; 255
 25e:	18 30       	cpi	r17, 0x08	; 8
 260:	d9 f7       	brne	.-10     	; 0x258 <_youWin_+0x4>



void _endCount_(void){

    DDRF &=0xF0;
 262:	80 b3       	in	r24, 0x10	; 16
 264:	80 7f       	andi	r24, 0xF0	; 240
 266:	80 bb       	out	0x10, r24	; 16
    PORTF &= 0xF0;
 268:	81 b3       	in	r24, 0x11	; 17
 26a:	80 7f       	andi	r24, 0xF0	; 240
 26c:	81 bb       	out	0x11, r24	; 17
        _waitState_();
    }

    _endCount_();

    delay(250);
 26e:	8a ef       	ldi	r24, 0xFA	; 250
 270:	90 e0       	ldi	r25, 0x00	; 0
 272:	0e 94 17 02 	call	0x42e	; 0x42e <delay>





}
 276:	1f 91       	pop	r17
 278:	08 95       	ret

0000027a <_startGame_>:
void _startGame_(void){


    static uint8_t seed = SEED;

    uint8_t random=myRand(seed);
 27a:	80 91 11 02 	lds	r24, 0x0211
 27e:	0e 94 3a 02 	call	0x474	; 0x474 <myRand>
 282:	e8 2f       	mov	r30, r24
    seed = random;
 284:	80 93 11 02 	sts	0x0211, r24

    uint8_t indice = random % 8;

    DDRF = _CONF_DDR[indice];
 288:	e7 70       	andi	r30, 0x07	; 7
 28a:	f0 e0       	ldi	r31, 0x00	; 0
 28c:	df 01       	movw	r26, r30
 28e:	a0 50       	subi	r26, 0x00	; 0
 290:	be 4f       	sbci	r27, 0xFE	; 254
 292:	8c 91       	ld	r24, X
 294:	80 bb       	out	0x10, r24	; 16
    PORTF = _CONF_PORT[indice];
 296:	e8 5f       	subi	r30, 0xF8	; 248
 298:	fd 4f       	sbci	r31, 0xFD	; 253
 29a:	80 81       	ld	r24, Z
 29c:	81 bb       	out	0x11, r24	; 17
    delay(100);
 29e:	84 e6       	ldi	r24, 0x64	; 100
 2a0:	90 e0       	ldi	r25, 0x00	; 0
 2a2:	0e 94 17 02 	call	0x42e	; 0x42e <delay>

}
 2a6:	08 95       	ret

000002a8 <updateLeds>:


void updateLeds(uint8_t gameState){


    switch(gameState){
 2a8:	83 30       	cpi	r24, 0x03	; 3
 2aa:	91 f0       	breq	.+36     	; 0x2d0 <updateLeds+0x28>
 2ac:	84 30       	cpi	r24, 0x04	; 4
 2ae:	28 f4       	brcc	.+10     	; 0x2ba <updateLeds+0x12>
 2b0:	81 30       	cpi	r24, 0x01	; 1
 2b2:	41 f0       	breq	.+16     	; 0x2c4 <updateLeds+0x1c>
 2b4:	82 30       	cpi	r24, 0x02	; 2
 2b6:	c1 f4       	brne	.+48     	; 0x2e8 <updateLeds+0x40>
 2b8:	08 c0       	rjmp	.+16     	; 0x2ca <updateLeds+0x22>
 2ba:	85 30       	cpi	r24, 0x05	; 5
 2bc:	99 f0       	breq	.+38     	; 0x2e4 <updateLeds+0x3c>
 2be:	86 30       	cpi	r24, 0x06	; 6
 2c0:	99 f4       	brne	.+38     	; 0x2e8 <updateLeds+0x40>
 2c2:	0d c0       	rjmp	.+26     	; 0x2de <updateLeds+0x36>

        case eWaitForStart : _waitState_(); break;
 2c4:	0e 94 0d 01 	call	0x21a	; 0x21a <_waitState_>
 2c8:	08 95       	ret

        case eStartCount: _startGame_(); break;
 2ca:	0e 94 3d 01 	call	0x27a	; 0x27a <_startGame_>
 2ce:	08 95       	ret



void _endCount_(void){

    DDRF &=0xF0;
 2d0:	80 b3       	in	r24, 0x10	; 16
 2d2:	80 7f       	andi	r24, 0xF0	; 240
 2d4:	80 bb       	out	0x10, r24	; 16
    PORTF &= 0xF0;
 2d6:	81 b3       	in	r24, 0x11	; 17
 2d8:	80 7f       	andi	r24, 0xF0	; 240
 2da:	81 bb       	out	0x11, r24	; 17
 2dc:	08 95       	ret

        case eStartCount: _startGame_(); break;

        case eEndCount : _endCount_(); break;

        case eYouLoose : _youLoose_(); break;
 2de:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <_youLoose_>
 2e2:	08 95       	ret

        case eYouWin: _youWin_(); break;
 2e4:	0e 94 2a 01 	call	0x254	; 0x254 <_youWin_>
 2e8:	08 95       	ret

000002ea <check_Btn>:
}



//el check_btn  sera un poquito diferente
uint8_t check_Btn(){
 2ea:	cf 93       	push	r28
 2ec:	df 93       	push	r29


    if(PINF & (1<<BTN_PIN)){
 2ee:	7f 99       	sbic	0x0f, 7	; 15
 2f0:	1b c0       	rjmp	.+54     	; 0x328 <check_Btn+0x3e>
    //si hay 1 en ese pin quiere decri que no esta precionado por lo que no sabemos que hay

        return eBtnUndefined;
    }

    delay(30); // un delay para un antirebote por software
 2f2:	8e e1       	ldi	r24, 0x1E	; 30
 2f4:	90 e0       	ldi	r25, 0x00	; 0
 2f6:	0e 94 17 02 	call	0x42e	; 0x42e <delay>

    if(PINF & (1<<BTN_PIN)) return eBtnUndefined; // hacemos lo mismos
 2fa:	7f 99       	sbic	0x0f, 7	; 15
 2fc:	15 c0       	rjmp	.+42     	; 0x328 <check_Btn+0x3e>
    uint16_t tiempoPrecionado = 0;




    if(!(PINF & (1<<BTN_PIN))){
 2fe:	7f 99       	sbic	0x0f, 7	; 15
 300:	12 c0       	rjmp	.+36     	; 0x326 <check_Btn+0x3c>
 302:	c0 e0       	ldi	r28, 0x00	; 0
 304:	d0 e0       	ldi	r29, 0x00	; 0
 306:	0b c0       	rjmp	.+22     	; 0x31e <check_Btn+0x34>

    //pero si es 0 que se esta precionando es 1 lo que quiere decir qeu se esta precionando

        while(!(PINF & (1<<BTN_PIN))){

            delay_103us();
 308:	0e 94 43 02 	call	0x486	; 0x486 <delay_103us>
            tiempoPrecionado++;
 30c:	21 96       	adiw	r28, 0x01	; 1

            if(tiempoPrecionado >= 9708){
 30e:	85 e2       	ldi	r24, 0x25	; 37
 310:	cc 3e       	cpi	r28, 0xEC	; 236
 312:	d8 07       	cpc	r29, r24
 314:	20 f0       	brcs	.+8      	; 0x31e <check_Btn+0x34>

                if(PINF & (1<<BTN_PIN)){
 316:	7f 9b       	sbis	0x0f, 7	; 15
 318:	02 c0       	rjmp	.+4      	; 0x31e <check_Btn+0x34>
 31a:	82 e0       	ldi	r24, 0x02	; 2
 31c:	06 c0       	rjmp	.+12     	; 0x32a <check_Btn+0x40>
    //este me quiere decir lo contrario, quiere decir que si no esta precionado me manda un 1 por loq ue aqui lo inverito
    //lo que seria un 0, por lo que no entraira

    //pero si es 0 que se esta precionando es 1 lo que quiere decir qeu se esta precionando

        while(!(PINF & (1<<BTN_PIN))){
 31e:	7f 9b       	sbis	0x0f, 7	; 15
 320:	f3 cf       	rjmp	.-26     	; 0x308 <check_Btn+0x1e>
 322:	81 e0       	ldi	r24, 0x01	; 1
 324:	02 c0       	rjmp	.+4      	; 0x32a <check_Btn+0x40>
 326:	01 c0       	rjmp	.+2      	; 0x32a <check_Btn+0x40>
    if((!(PIN & (1<<BTN_PIN))){
        return eBtnUndefined;
    }*/


}
 328:	80 e0       	ldi	r24, 0x00	; 0
 32a:	df 91       	pop	r29
 32c:	cf 91       	pop	r28
 32e:	08 95       	ret

00000330 <main>:

// Global variable
uint32_t millis;

int main(void)
{
 330:	cf 92       	push	r12
 332:	df 92       	push	r13
 334:	ef 92       	push	r14
 336:	ff 92       	push	r15
 338:	0f 93       	push	r16
 33a:	1f 93       	push	r17
 33c:	cf 93       	push	r28
 33e:	df 93       	push	r29
    uint8_t currentGameState = eGameRestart;
    uint16_t countdown = 0;
    uint16_t countup = 0;
    InitPorts();
 340:	0e 94 95 00 	call	0x12a	; 0x12a <InitPorts>
 344:	10 e0       	ldi	r17, 0x00	; 0
 346:	ee 24       	eor	r14, r14
 348:	ff 24       	eor	r15, r15
        switch (currentGameState)
        {
        case eGameRestart:
        {
            //countdown = (myRand(SEED) + 1) * 20;
            countdown=((myRand(SEED) % 10) + 1) * 20;
 34a:	84 e1       	ldi	r24, 0x14	; 20
 34c:	c8 2e       	mov	r12, r24
 34e:	d1 2c       	mov	r13, r1


    while (1)
    {

		 countdown=((myRand(SEED) % 10) + 1) * 20;
 350:	81 e0       	ldi	r24, 0x01	; 1
 352:	0e 94 3a 02 	call	0x474	; 0x474 <myRand>
 356:	08 2f       	mov	r16, r24
		 __asm__("nop");
 358:	00 00       	nop
		
		

        switch (check_Btn())
 35a:	0e 94 75 01 	call	0x2ea	; 0x2ea <check_Btn>
 35e:	81 30       	cpi	r24, 0x01	; 1
 360:	19 f0       	breq	.+6      	; 0x368 <main+0x38>
 362:	82 30       	cpi	r24, 0x02	; 2
 364:	11 f4       	brne	.+4      	; 0x36a <main+0x3a>
 366:	1d c0       	rjmp	.+58     	; 0x3a2 <main+0x72>
        {
        case eBtnShortPressed:
            currentGameState++;
 368:	1f 5f       	subi	r17, 0xFF	; 255


    while (1)
    {

		 countdown=((myRand(SEED) % 10) + 1) * 20;
 36a:	80 2f       	mov	r24, r16
 36c:	6a e0       	ldi	r22, 0x0A	; 10
 36e:	0e 94 58 02 	call	0x4b0	; 0x4b0 <__udivmodqi4>
 372:	89 2f       	mov	r24, r25
 374:	90 e0       	ldi	r25, 0x00	; 0
 376:	01 96       	adiw	r24, 0x01	; 1
 378:	8c 9d       	mul	r24, r12
 37a:	90 01       	movw	r18, r0
 37c:	8d 9d       	mul	r24, r13
 37e:	30 0d       	add	r19, r0
 380:	9c 9d       	mul	r25, r12
 382:	30 0d       	add	r19, r0
 384:	11 24       	eor	r1, r1
        case eBtnLongPressed:
            currentGameState = eGameRestart;
            break;
        }

        switch (currentGameState)
 386:	12 30       	cpi	r17, 0x02	; 2
 388:	f1 f0       	breq	.+60     	; 0x3c6 <main+0x96>
 38a:	13 30       	cpi	r17, 0x03	; 3
 38c:	18 f4       	brcc	.+6      	; 0x394 <main+0x64>
 38e:	11 23       	and	r17, r17
 390:	41 f0       	breq	.+16     	; 0x3a2 <main+0x72>
 392:	32 c0       	rjmp	.+100    	; 0x3f8 <main+0xc8>
 394:	13 30       	cpi	r17, 0x03	; 3
 396:	19 f0       	breq	.+6      	; 0x39e <main+0x6e>
 398:	14 30       	cpi	r17, 0x04	; 4
 39a:	71 f5       	brne	.+92     	; 0x3f8 <main+0xc8>
 39c:	27 c0       	rjmp	.+78     	; 0x3ec <main+0xbc>
 39e:	14 e0       	ldi	r17, 0x04	; 4
 3a0:	2b c0       	rjmp	.+86     	; 0x3f8 <main+0xc8>
        {
        case eGameRestart:
        {
            //countdown = (myRand(SEED) + 1) * 20;
            countdown=((myRand(SEED) % 10) + 1) * 20;
 3a2:	81 e0       	ldi	r24, 0x01	; 1
 3a4:	0e 94 3a 02 	call	0x474	; 0x474 <myRand>
 3a8:	6a e0       	ldi	r22, 0x0A	; 10
 3aa:	0e 94 58 02 	call	0x4b0	; 0x4b0 <__udivmodqi4>
 3ae:	89 2f       	mov	r24, r25
 3b0:	90 e0       	ldi	r25, 0x00	; 0
 3b2:	01 96       	adiw	r24, 0x01	; 1
 3b4:	8c 9d       	mul	r24, r12
 3b6:	70 01       	movw	r14, r0
 3b8:	8d 9d       	mul	r24, r13
 3ba:	f0 0c       	add	r15, r0
 3bc:	9c 9d       	mul	r25, r12
 3be:	f0 0c       	add	r15, r0
 3c0:	11 24       	eor	r1, r1
 3c2:	11 e0       	ldi	r17, 0x01	; 1
 3c4:	19 c0       	rjmp	.+50     	; 0x3f8 <main+0xc8>
        }
        case eWaitForStart:
            break;
        case eStartCount:
        {
            countdown--;
 3c6:	e9 01       	movw	r28, r18
 3c8:	21 97       	sbiw	r28, 0x01	; 1

            if(_back_countdown > countdown){
 3ca:	ce 15       	cp	r28, r14
 3cc:	df 05       	cpc	r29, r15
 3ce:	50 f4       	brcc	.+20     	; 0x3e4 <main+0xb4>
                _back_countdown--;
 3d0:	08 94       	sec
 3d2:	e1 08       	sbc	r14, r1
 3d4:	f1 08       	sbc	r15, r1
                DDRB |= (1<<PB7);
 3d6:	27 9a       	sbi	0x04, 7	; 4
                SetBitPort(PORTB, 7);
 3d8:	2f 9a       	sbi	0x05, 7	; 5
                delay(500);
 3da:	84 ef       	ldi	r24, 0xF4	; 244
 3dc:	91 e0       	ldi	r25, 0x01	; 1
 3de:	0e 94 17 02 	call	0x42e	; 0x42e <delay>
                ClrBitPort(PORTB,7);
 3e2:	2f 98       	cbi	0x05, 7	; 5
            }


            if (countdown == 0)
 3e4:	cd 2b       	or	r28, r29
 3e6:	41 f4       	brne	.+16     	; 0x3f8 <main+0xc8>
 3e8:	13 e0       	ldi	r17, 0x03	; 3
 3ea:	06 c0       	rjmp	.+12     	; 0x3f8 <main+0xc8>
                countup++;
            break;
        }
        case eGameOver:
        {
            if ((countdown + countup) > TIME_WINDOW)
 3ec:	2d 52       	subi	r18, 0x2D	; 45
 3ee:	31 40       	sbci	r19, 0x01	; 1
 3f0:	10 f4       	brcc	.+4      	; 0x3f6 <main+0xc6>
 3f2:	15 e0       	ldi	r17, 0x05	; 5
 3f4:	01 c0       	rjmp	.+2      	; 0x3f8 <main+0xc8>
 3f6:	16 e0       	ldi	r17, 0x06	; 6
                currentGameState = eYouWin;
            break;
        }
        }

        updateLeds(currentGameState);
 3f8:	81 2f       	mov	r24, r17
 3fa:	0e 94 54 01 	call	0x2a8	; 0x2a8 <updateLeds>
        delay(1);
 3fe:	81 e0       	ldi	r24, 0x01	; 1
 400:	90 e0       	ldi	r25, 0x00	; 0
 402:	0e 94 17 02 	call	0x42e	; 0x42e <delay>
        millis++;
 406:	80 91 16 02 	lds	r24, 0x0216
 40a:	90 91 17 02 	lds	r25, 0x0217
 40e:	a0 91 18 02 	lds	r26, 0x0218
 412:	b0 91 19 02 	lds	r27, 0x0219
 416:	01 96       	adiw	r24, 0x01	; 1
 418:	a1 1d       	adc	r26, r1
 41a:	b1 1d       	adc	r27, r1
 41c:	80 93 16 02 	sts	0x0216, r24
 420:	90 93 17 02 	sts	0x0217, r25
 424:	a0 93 18 02 	sts	0x0218, r26
 428:	b0 93 19 02 	sts	0x0219, r27
 42c:	91 cf       	rjmp	.-222    	; 0x350 <main+0x20>

0000042e <delay>:
delay:

	; en este tendre que hacer muchos descuentos por esto de
	;cunado sea 0 y  lo demas

	cpi r24, 0x00 ; 1
 42e:	80 30       	cpi	r24, 0x00	; 0
	breq final ;2 - 1
 430:	49 f0       	breq	.+18     	; 0x444 <final>

	cpi r24, 0x01
 432:	81 30       	cpi	r24, 0x01	; 1
	breq un_mSeg; si r24 es 1 ms entonces ira a una subrutina la cual durara
 434:	41 f0       	breq	.+16     	; 0x446 <un_mSeg>

00000436 <ciclo>:
	;dira 1ms segun lo que se mando por parametro


	ciclo:

		call delay_general
 436:	0e 94 2f 02 	call	0x45e	; 0x45e <delay_general>

		sbiw r24, 1 ; 2
 43a:	01 97       	sbiw	r24, 0x01	; 1

		cpi r24, 0x01 ;1
 43c:	81 30       	cpi	r24, 0x01	; 1
		brne ciclo ; 2 - 1
 43e:	d9 f7       	brne	.-10     	; 0x436 <ciclo>

		cpi r24,0x01
 440:	81 30       	cpi	r24, 0x01	; 1
		breq un_mSeg ; se cumple siempre
 442:	09 f0       	breq	.+2      	; 0x446 <un_mSeg>

00000444 <final>:


final:
	; agrego un nop porque al final

	ret
 444:	08 95       	ret

00000446 <un_mSeg>:
	; jmp -> 3 ciclos

	;usaremos de igual r16-r17-r18


	ldi r16,2 ; 1
 446:	02 e0       	ldi	r16, 0x02	; 2

00000448 <ciclo0_1mS>:
	ciclo0_1mS:
		ldi r17,11 ; 1x
 448:	1b e0       	ldi	r17, 0x0B	; 11
	...

0000044c <ciclo1_1mS>:
		nop ; 1x

		ciclo1_1mS:
			ldi r18, 241 ; 1xy
 44c:	21 ef       	ldi	r18, 0xF1	; 241

0000044e <ciclo2_1mS>:

			ciclo2_1mS:
				dec r18 ; 1xyz
 44e:	2a 95       	dec	r18
				brne ciclo2_1mS ; xy(2z-1)
 450:	f1 f7       	brne	.-4      	; 0x44e <ciclo2_1mS>

			dec r17 ; 1xy
 452:	1a 95       	dec	r17
			brne ciclo1_1mS ;x(2y-1)
 454:	d9 f7       	brne	.-10     	; 0x44c <ciclo1_1mS>

		dec r16 ; 1x
 456:	0a 95       	dec	r16
		brne ciclo0_1mS ; (2x-1)
 458:	b9 f7       	brne	.-18     	; 0x448 <ciclo0_1mS>

	jmp final
 45a:	0c 94 22 02 	jmp	0x444	; 0x444 <final>

0000045e <delay_general>:

	; este no va a durar exactamento delo 16,000 porque va a contar
	;en su ciclo las comparaciones fuera y al parecer tan solo tendra
	;en el ultimo que le faltaria 1 de la comparacion que no es correcta

	ldi r16, 115 ; 1
 45e:	03 e7       	ldi	r16, 0x73	; 115

00000460 <ciclo_0>:

	ciclo_0:
		ldi r17, 1 ; 1x
 460:	11 e0       	ldi	r17, 0x01	; 1
	...

00000464 <ciclo_1>:
		nop

		ciclo_1:

			ldi r18, 44 ; 1xy
 464:	2c e2       	ldi	r18, 0x2C	; 44

00000466 <ciclo_2>:
			ciclo_2:
				dec r18 ; 1zxy
 466:	2a 95       	dec	r18
				brne ciclo_2 ; xy(2z-1)
 468:	f1 f7       	brne	.-4      	; 0x466 <ciclo_2>

			dec r17 ; 1xy
 46a:	1a 95       	dec	r17
			brne ciclo_1 ;x(2y-1)
 46c:	d9 f7       	brne	.-10     	; 0x464 <ciclo_1>

		dec r16 ; 1x
 46e:	0a 95       	dec	r16
		brne ciclo_0 ;(2x-1)
 470:	b9 f7       	brne	.-18     	; 0x460 <ciclo_0>
	ret
 472:	08 95       	ret

00000474 <myRand>:

myRand:
    ; Entrada: seed en r24
    ; Salida: n?mero pseudoaleatorio en r24

    mov r16, r24      ; r16 = seed
 474:	08 2f       	mov	r16, r24

    ; Multiplicar X por 5: (X << 2) + X
    mov r18, r16      ; r18 = copia de X
 476:	20 2f       	mov	r18, r16
    lsl r16           ; X * 2
 478:	00 0f       	add	r16, r16
    lsl r16           ; X * 4
 47a:	00 0f       	add	r16, r16
    add r16, r18      ; X * 5
 47c:	02 0f       	add	r16, r18

    ; Sumar 1
    ldi r18, 1
 47e:	21 e0       	ldi	r18, 0x01	; 1
    add r16, r18      ; 5*X + 1 (mod 256 autom?ticamente)
 480:	02 0f       	add	r16, r18

    ; Devolver resultado en r24
    mov r24, r16
 482:	80 2f       	mov	r24, r16

    ret
 484:	08 95       	ret

00000486 <delay_103us>:


delay_103us:


	nop
 486:	00 00       	nop
	nop
 488:	00 00       	nop


	ldi r22,5
 48a:	65 e0       	ldi	r22, 0x05	; 5
	ldi r21, 7
 48c:	57 e0       	ldi	r21, 0x07	; 7

0000048e <nxt0>:

nxt0:
	nop
 48e:	00 00       	nop
	nop
 490:	00 00       	nop
	nop
 492:	00 00       	nop
	ldi r20, 8
 494:	48 e0       	ldi	r20, 0x08	; 8

00000496 <nxt1>:


nxt1:
	dec r21
 496:	5a 95       	dec	r21
	nop
 498:	00 00       	nop
	nop
 49a:	00 00       	nop
	brne nxt1
 49c:	e1 f7       	brne	.-8      	; 0x496 <nxt1>

0000049e <nxt2>:

nxt2:
	ldi r21,7
 49e:	57 e0       	ldi	r21, 0x07	; 7
	nop
 4a0:	00 00       	nop
	nop
 4a2:	00 00       	nop
	dec r20
 4a4:	4a 95       	dec	r20
	brne nxt1
 4a6:	b9 f7       	brne	.-18     	; 0x496 <nxt1>

	dec r22
 4a8:	6a 95       	dec	r22
	nop
 4aa:	00 00       	nop
	brne nxt0
 4ac:	81 f7       	brne	.-32     	; 0x48e <nxt0>

	ret
 4ae:	08 95       	ret

000004b0 <__udivmodqi4>:
 4b0:	99 1b       	sub	r25, r25
 4b2:	79 e0       	ldi	r23, 0x09	; 9
 4b4:	04 c0       	rjmp	.+8      	; 0x4be <__udivmodqi4_ep>

000004b6 <__udivmodqi4_loop>:
 4b6:	99 1f       	adc	r25, r25
 4b8:	96 17       	cp	r25, r22
 4ba:	08 f0       	brcs	.+2      	; 0x4be <__udivmodqi4_ep>
 4bc:	96 1b       	sub	r25, r22

000004be <__udivmodqi4_ep>:
 4be:	88 1f       	adc	r24, r24
 4c0:	7a 95       	dec	r23
 4c2:	c9 f7       	brne	.-14     	; 0x4b6 <__udivmodqi4_loop>
 4c4:	80 95       	com	r24
 4c6:	08 95       	ret

000004c8 <_exit>:
 4c8:	f8 94       	cli

000004ca <__stop_program>:
 4ca:	ff cf       	rjmp	.-2      	; 0x4ca <__stop_program>
