
practica7.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000048  00800200  0000083c  000008d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000083c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000210  00800248  00800248  00000918  2**0
                  ALLOC
  3 .debug_aranges 00000040  00000000  00000000  00000918  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 0000012d  00000000  00000000  00000958  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000078a  00000000  00000000  00000a85  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000272  00000000  00000000  0000120f  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000062b  00000000  00000000  00001481  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000110  00000000  00000000  00001aac  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000270  00000000  00000000  00001bbc  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000005d2  00000000  00000000  00001e2c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 c5 01 	jmp	0x38a	; 0x38a <__vector_25>
  68:	0c 94 93 01 	jmp	0x326	; 0x326 <__vector_26>
  6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	ec e3       	ldi	r30, 0x3C	; 60
  fc:	f8 e0       	ldi	r31, 0x08	; 8
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a8 34       	cpi	r26, 0x48	; 72
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	14 e0       	ldi	r17, 0x04	; 4
 110:	a8 e4       	ldi	r26, 0x48	; 72
 112:	b2 e0       	ldi	r27, 0x02	; 2
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	a8 35       	cpi	r26, 0x58	; 88
 11a:	b1 07       	cpc	r27, r17
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	0e 94 95 00 	call	0x12a	; 0x12a <main>
 122:	0c 94 1c 04 	jmp	0x838	; 0x838 <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <main>:
#include <avr/io.h>
#include "UART.h"

int main( void )
{
 12a:	cf 92       	push	r12
 12c:	df 92       	push	r13
 12e:	ef 92       	push	r14
 130:	ff 92       	push	r15
 132:	0f 93       	push	r16
 134:	1f 93       	push	r17
 136:	df 93       	push	r29
 138:	cf 93       	push	r28
 13a:	cd b7       	in	r28, 0x3d	; 61
 13c:	de b7       	in	r29, 0x3e	; 62
 13e:	a8 97       	sbiw	r28, 0x28	; 40
 140:	0f b6       	in	r0, 0x3f	; 63
 142:	f8 94       	cli
 144:	de bf       	out	0x3e, r29	; 62
 146:	0f be       	out	0x3f, r0	; 63
 148:	cd bf       	out	0x3d, r28	; 61
    char cad[20];
    char cadUart3[20];
    uint16_t num;

    UART_Ini(0,12345,8,1,2);
 14a:	80 e0       	ldi	r24, 0x00	; 0
 14c:	49 e3       	ldi	r20, 0x39	; 57
 14e:	50 e3       	ldi	r21, 0x30	; 48
 150:	60 e0       	ldi	r22, 0x00	; 0
 152:	70 e0       	ldi	r23, 0x00	; 0
 154:	28 e0       	ldi	r18, 0x08	; 8
 156:	01 e0       	ldi	r16, 0x01	; 1
 158:	92 e0       	ldi	r25, 0x02	; 2
 15a:	e9 2e       	mov	r14, r25
 15c:	0e 94 31 01 	call	0x262	; 0x262 <UART_Ini>
    UART_Ini(2,115200,8,0,1);
 160:	82 e0       	ldi	r24, 0x02	; 2
 162:	40 e0       	ldi	r20, 0x00	; 0
 164:	52 ec       	ldi	r21, 0xC2	; 194
 166:	61 e0       	ldi	r22, 0x01	; 1
 168:	70 e0       	ldi	r23, 0x00	; 0
 16a:	28 e0       	ldi	r18, 0x08	; 8
 16c:	00 e0       	ldi	r16, 0x00	; 0
 16e:	ee 24       	eor	r14, r14
 170:	e3 94       	inc	r14
 172:	0e 94 31 01 	call	0x262	; 0x262 <UART_Ini>
    UART_Ini(3,115200,8,0,1);
 176:	83 e0       	ldi	r24, 0x03	; 3
 178:	40 e0       	ldi	r20, 0x00	; 0
 17a:	52 ec       	ldi	r21, 0xC2	; 194
 17c:	61 e0       	ldi	r22, 0x01	; 1
 17e:	70 e0       	ldi	r23, 0x00	; 0
 180:	28 e0       	ldi	r18, 0x08	; 8
 182:	0e 94 31 01 	call	0x262	; 0x262 <UART_Ini>
        UART_setColor(0,YELLOW);
        UART_puts(0,"Introduce un número:");

        UART_gotoxy(0,22,2);
        UART_setColor(0,GREEN);
        UART_gets(0,cad);
 186:	7e 01       	movw	r14, r28
 188:	08 94       	sec
 18a:	e1 1c       	adc	r14, r1
 18c:	f1 1c       	adc	r15, r1
// -------------------------------------------
        // Cycle through UART2->UART3
        UART_puts(2,cad);
        UART_puts(2,"\r");
        UART_gets(3,cadUart3);
 18e:	85 e1       	ldi	r24, 0x15	; 21
 190:	c8 2e       	mov	r12, r24
 192:	d1 2c       	mov	r13, r1
 194:	cc 0e       	add	r12, r28
 196:	dd 1e       	adc	r13, r29
    UART_Ini(0,12345,8,1,2);
    UART_Ini(2,115200,8,0,1);
    UART_Ini(3,115200,8,0,1);
    while(1)
    {
        UART_getchar(0);
 198:	80 e0       	ldi	r24, 0x00	; 0
 19a:	0e 94 36 02 	call	0x46c	; 0x46c <UART_getchar>
        UART_clrscr(0);
 19e:	80 e0       	ldi	r24, 0x00	; 0
 1a0:	0e 94 ca 02 	call	0x594	; 0x594 <UART_clrscr>

        UART_gotoxy(0,2,2);
 1a4:	80 e0       	ldi	r24, 0x00	; 0
 1a6:	62 e0       	ldi	r22, 0x02	; 2
 1a8:	42 e0       	ldi	r20, 0x02	; 2
 1aa:	0e 94 24 03 	call	0x648	; 0x648 <UART_gotoxy>
        UART_setColor(0,YELLOW);
 1ae:	80 e0       	ldi	r24, 0x00	; 0
 1b0:	61 e2       	ldi	r22, 0x21	; 33
 1b2:	0e 94 d7 02 	call	0x5ae	; 0x5ae <UART_setColor>
        UART_puts(0,"Introduce un número:");
 1b6:	80 e0       	ldi	r24, 0x00	; 0
 1b8:	60 e0       	ldi	r22, 0x00	; 0
 1ba:	72 e0       	ldi	r23, 0x02	; 2
 1bc:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>

        UART_gotoxy(0,22,2);
 1c0:	80 e0       	ldi	r24, 0x00	; 0
 1c2:	66 e1       	ldi	r22, 0x16	; 22
 1c4:	42 e0       	ldi	r20, 0x02	; 2
 1c6:	0e 94 24 03 	call	0x648	; 0x648 <UART_gotoxy>
        UART_setColor(0,GREEN);
 1ca:	80 e0       	ldi	r24, 0x00	; 0
 1cc:	60 e2       	ldi	r22, 0x20	; 32
 1ce:	0e 94 d7 02 	call	0x5ae	; 0x5ae <UART_setColor>
        UART_gets(0,cad);
 1d2:	80 e0       	ldi	r24, 0x00	; 0
 1d4:	b7 01       	movw	r22, r14
 1d6:	0e 94 67 02 	call	0x4ce	; 0x4ce <UART_gets>
// -------------------------------------------
        // Cycle through UART2->UART3
        UART_puts(2,cad);
 1da:	82 e0       	ldi	r24, 0x02	; 2
 1dc:	b7 01       	movw	r22, r14
 1de:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
        UART_puts(2,"\r");
 1e2:	82 e0       	ldi	r24, 0x02	; 2
 1e4:	65 e1       	ldi	r22, 0x15	; 21
 1e6:	72 e0       	ldi	r23, 0x02	; 2
 1e8:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
        UART_gets(3,cadUart3);
 1ec:	83 e0       	ldi	r24, 0x03	; 3
 1ee:	b6 01       	movw	r22, r12
 1f0:	0e 94 67 02 	call	0x4ce	; 0x4ce <UART_gets>
        UART_gotoxy(0,5,3);
 1f4:	80 e0       	ldi	r24, 0x00	; 0
 1f6:	65 e0       	ldi	r22, 0x05	; 5
 1f8:	43 e0       	ldi	r20, 0x03	; 3
 1fa:	0e 94 24 03 	call	0x648	; 0x648 <UART_gotoxy>
        UART_puts(0,cadUart3);
 1fe:	80 e0       	ldi	r24, 0x00	; 0
 200:	b6 01       	movw	r22, r12
 202:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
// -------------------------------------------
        num = atoi(cad);
 206:	c7 01       	movw	r24, r14
 208:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <atoi>
 20c:	8c 01       	movw	r16, r24
        itoa(num,cad,16);
 20e:	b7 01       	movw	r22, r14
 210:	40 e1       	ldi	r20, 0x10	; 16
 212:	0e 94 44 03 	call	0x688	; 0x688 <itoa>

        UART_gotoxy(0,5,4);
 216:	80 e0       	ldi	r24, 0x00	; 0
 218:	65 e0       	ldi	r22, 0x05	; 5
 21a:	44 e0       	ldi	r20, 0x04	; 4
 21c:	0e 94 24 03 	call	0x648	; 0x648 <UART_gotoxy>
        UART_setColor(0,BLUE);
 220:	80 e0       	ldi	r24, 0x00	; 0
 222:	62 e2       	ldi	r22, 0x22	; 34
 224:	0e 94 d7 02 	call	0x5ae	; 0x5ae <UART_setColor>
        UART_puts(0,"Hex: ");
 228:	80 e0       	ldi	r24, 0x00	; 0
 22a:	67 e1       	ldi	r22, 0x17	; 23
 22c:	72 e0       	ldi	r23, 0x02	; 2
 22e:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
        UART_puts(0,cad);
 232:	80 e0       	ldi	r24, 0x00	; 0
 234:	b7 01       	movw	r22, r14
 236:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
        itoa(num,cad,2);
 23a:	c8 01       	movw	r24, r16
 23c:	b7 01       	movw	r22, r14
 23e:	42 e0       	ldi	r20, 0x02	; 2
 240:	0e 94 44 03 	call	0x688	; 0x688 <itoa>

        UART_gotoxy(0,5,5);
 244:	80 e0       	ldi	r24, 0x00	; 0
 246:	65 e0       	ldi	r22, 0x05	; 5
 248:	45 e0       	ldi	r20, 0x05	; 5
 24a:	0e 94 24 03 	call	0x648	; 0x648 <UART_gotoxy>
        UART_puts(0,"Bin: ");
 24e:	80 e0       	ldi	r24, 0x00	; 0
 250:	6d e1       	ldi	r22, 0x1D	; 29
 252:	72 e0       	ldi	r23, 0x02	; 2
 254:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
        UART_puts(0,cad);
 258:	80 e0       	ldi	r24, 0x00	; 0
 25a:	b7 01       	movw	r22, r14
 25c:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
 260:	9b cf       	rjmp	.-202    	; 0x198 <main+0x6e>

00000262 <UART_Ini>:



// Prototypes
// Initialization
UART_Ini(uint8_t com, uint32_t baudrate, uint8_t size, uint8_t parity, uint8_t stop){
 262:	af 92       	push	r10
 264:	bf 92       	push	r11
 266:	cf 92       	push	r12
 268:	df 92       	push	r13
 26a:	ef 92       	push	r14
 26c:	0f 93       	push	r16
 26e:	cf 93       	push	r28
 270:	df 93       	push	r29
 272:	5a 01       	movw	r10, r20
 274:	6b 01       	movw	r12, r22
 276:	92 2f       	mov	r25, r18
 278:	2e 2d       	mov	r18, r14


    //la inicaliazacion e la misma

    UART_reg_t *myUART = UART_offset[com]; // eligo a mi UART
 27a:	e8 2f       	mov	r30, r24
 27c:	f0 e0       	ldi	r31, 0x00	; 0
 27e:	ee 0f       	add	r30, r30
 280:	ff 1f       	adc	r31, r31
 282:	e0 5c       	subi	r30, 0xC0	; 192
 284:	fd 4f       	sbci	r31, 0xFD	; 253
 286:	c0 81       	ld	r28, Z
 288:	d1 81       	ldd	r29, Z+1	; 0x01

    //habilitar las interrupciones de RX
    myUART->UCSRB = (1 << TXEN0) | (1 << RXEN0) | (1 << RXCIE0); // Habilita TX y RX para UART0
 28a:	88 e9       	ldi	r24, 0x98	; 152
 28c:	89 83       	std	Y+1, r24	; 0x01

    uint8_t parity_mode=0;

    switch(parity){
 28e:	01 30       	cpi	r16, 0x01	; 1
 290:	21 f0       	breq	.+8      	; 0x29a <UART_Ini+0x38>
 292:	02 30       	cpi	r16, 0x02	; 2
 294:	21 f4       	brne	.+8      	; 0x29e <UART_Ini+0x3c>
 296:	82 e0       	ldi	r24, 0x02	; 2
 298:	03 c0       	rjmp	.+6      	; 0x2a0 <UART_Ini+0x3e>
 29a:	83 e0       	ldi	r24, 0x03	; 3
 29c:	01 c0       	rjmp	.+2      	; 0x2a0 <UART_Ini+0x3e>
 29e:	80 e0       	ldi	r24, 0x00	; 0

    }


    uint8_t stop_mode= (stop == 1)? 0:1;
    myUART->UCSRC = (parity_mode << UPM00) | (stop_mode <<USBS0);
 2a0:	e8 2f       	mov	r30, r24
 2a2:	f0 e0       	ldi	r31, 0x00	; 0
 2a4:	54 e0       	ldi	r21, 0x04	; 4
 2a6:	ee 0f       	add	r30, r30
 2a8:	ff 1f       	adc	r31, r31
 2aa:	5a 95       	dec	r21
 2ac:	e1 f7       	brne	.-8      	; 0x2a6 <UART_Ini+0x44>
 2ae:	60 e0       	ldi	r22, 0x00	; 0
 2b0:	70 e0       	ldi	r23, 0x00	; 0
 2b2:	21 30       	cpi	r18, 0x01	; 1
 2b4:	11 f0       	breq	.+4      	; 0x2ba <UART_Ini+0x58>
 2b6:	61 e0       	ldi	r22, 0x01	; 1
 2b8:	70 e0       	ldi	r23, 0x00	; 0
 2ba:	43 e0       	ldi	r20, 0x03	; 3
 2bc:	66 0f       	add	r22, r22
 2be:	77 1f       	adc	r23, r23
 2c0:	4a 95       	dec	r20
 2c2:	e1 f7       	brne	.-8      	; 0x2bc <UART_Ini+0x5a>
 2c4:	8e 2f       	mov	r24, r30
 2c6:	86 2b       	or	r24, r22
 2c8:	8a 83       	std	Y+2, r24	; 0x02
    //tamanio del frame
	if (size == 9) {
 2ca:	99 30       	cpi	r25, 0x09	; 9
 2cc:	39 f4       	brne	.+14     	; 0x2dc <UART_Ini+0x7a>
        myUART->UCSRC |= (3 << UCSZ00); // UCSZ01:UCSZ00 = 0b11
 2ce:	8a 81       	ldd	r24, Y+2	; 0x02
 2d0:	86 60       	ori	r24, 0x06	; 6
 2d2:	8a 83       	std	Y+2, r24	; 0x02
        myUART->UCSRB |= (1 << UCSZ02); // Habilitar bit 9
 2d4:	89 81       	ldd	r24, Y+1	; 0x01
 2d6:	84 60       	ori	r24, 0x04	; 4
 2d8:	89 83       	std	Y+1, r24	; 0x01
 2da:	08 c0       	rjmp	.+16     	; 0x2ec <UART_Ini+0x8a>
    } else
     {
        myUART->UCSRC |= ((size - 5) << UCSZ00); // Ej: 8 bits ? 3 << UCSZ00
 2dc:	2a 81       	ldd	r18, Y+2	; 0x02
 2de:	89 2f       	mov	r24, r25
 2e0:	90 e0       	ldi	r25, 0x00	; 0
 2e2:	05 97       	sbiw	r24, 0x05	; 5
 2e4:	88 0f       	add	r24, r24
 2e6:	99 1f       	adc	r25, r25
 2e8:	28 2b       	or	r18, r24
 2ea:	2a 83       	std	Y+2, r18	; 0x02
    }

    uint16_t v_UBRR = (FOSC / (16 * baudrate)) - 1 ;
 2ec:	84 e0       	ldi	r24, 0x04	; 4
 2ee:	aa 0c       	add	r10, r10
 2f0:	bb 1c       	adc	r11, r11
 2f2:	cc 1c       	adc	r12, r12
 2f4:	dd 1c       	adc	r13, r13
 2f6:	8a 95       	dec	r24
 2f8:	d1 f7       	brne	.-12     	; 0x2ee <UART_Ini+0x8c>
 2fa:	60 e0       	ldi	r22, 0x00	; 0
 2fc:	74 e2       	ldi	r23, 0x24	; 36
 2fe:	84 ef       	ldi	r24, 0xF4	; 244
 300:	90 e0       	ldi	r25, 0x00	; 0
 302:	a6 01       	movw	r20, r12
 304:	95 01       	movw	r18, r10
 306:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <__udivmodsi4>
 30a:	21 50       	subi	r18, 0x01	; 1
 30c:	30 40       	sbci	r19, 0x00	; 0
    myUART->UBRR = v_UBRR;
 30e:	3d 83       	std	Y+5, r19	; 0x05
 310:	2c 83       	std	Y+4, r18	; 0x04


    //para empezar este UART debe de tener habilitado las interrupcioens

    sei(); //con esta funcionse habilitan las interruciones de manerja global
 312:	78 94       	sei

}
 314:	df 91       	pop	r29
 316:	cf 91       	pop	r28
 318:	0f 91       	pop	r16
 31a:	ef 90       	pop	r14
 31c:	df 90       	pop	r13
 31e:	cf 90       	pop	r12
 320:	bf 90       	pop	r11
 322:	af 90       	pop	r10
 324:	08 95       	ret

00000326 <__vector_26>:



//la ISR debe de accionarse, dependiod a que UART le correxponde la interrupcion.
//ahora mismo el perifereico esta listo para mandar una interrupcion, por lo que ahora le toca a la ISR atender esa interrupcion
ISR(USART0_UDRE_vect){
 326:	1f 92       	push	r1
 328:	0f 92       	push	r0
 32a:	0f b6       	in	r0, 0x3f	; 63
 32c:	0f 92       	push	r0
 32e:	0b b6       	in	r0, 0x3b	; 59
 330:	0f 92       	push	r0
 332:	11 24       	eor	r1, r1
 334:	8f 93       	push	r24
 336:	9f 93       	push	r25
 338:	ef 93       	push	r30
 33a:	ff 93       	push	r31
     //primero lo que haremos es traer ese dato

     ring_buffer *tx = &tx_buffers[0]; //seleccionamos el apuntador que esta en la estrucutra 0 que es
     //el del UART 0

     if(tx->in_dx != tx->out_dx){
 33c:	90 91 88 02 	lds	r25, 0x0288
 340:	80 91 89 02 	lds	r24, 0x0289
 344:	98 17       	cp	r25, r24
 346:	89 f0       	breq	.+34     	; 0x36a <__vector_26+0x44>

        UDR0 = tx->buffer[tx->out_dx];
 348:	e0 91 89 02 	lds	r30, 0x0289
 34c:	f0 e0       	ldi	r31, 0x00	; 0
 34e:	e8 5b       	subi	r30, 0xB8	; 184
 350:	fd 4f       	sbci	r31, 0xFD	; 253
 352:	80 81       	ld	r24, Z
 354:	80 93 c6 00 	sts	0x00C6, r24
        tx->out_dx = (tx->out_dx + 1) % BUFFER_SIZE;
 358:	80 91 89 02 	lds	r24, 0x0289
 35c:	90 e0       	ldi	r25, 0x00	; 0
 35e:	01 96       	adiw	r24, 0x01	; 1
 360:	8f 73       	andi	r24, 0x3F	; 63
 362:	90 70       	andi	r25, 0x00	; 0
 364:	80 93 89 02 	sts	0x0289, r24
 368:	05 c0       	rjmp	.+10     	; 0x374 <__vector_26+0x4e>
     }else{

        UCSR0B &=~(1<< UDRIE0); // deshabilitamos interrupcion si no hay datos
 36a:	80 91 c1 00 	lds	r24, 0x00C1
 36e:	8f 7d       	andi	r24, 0xDF	; 223
 370:	80 93 c1 00 	sts	0x00C1, r24
     }

}
 374:	ff 91       	pop	r31
 376:	ef 91       	pop	r30
 378:	9f 91       	pop	r25
 37a:	8f 91       	pop	r24
 37c:	0f 90       	pop	r0
 37e:	0b be       	out	0x3b, r0	; 59
 380:	0f 90       	pop	r0
 382:	0f be       	out	0x3f, r0	; 63
 384:	0f 90       	pop	r0
 386:	1f 90       	pop	r1
 388:	18 95       	reti

0000038a <__vector_25>:


//empezemos por la ISR como vamos  tratar cunado hay un dato denotr
//interrupcion para RX
ISR(USART0_RX_vect){
 38a:	1f 92       	push	r1
 38c:	0f 92       	push	r0
 38e:	0f b6       	in	r0, 0x3f	; 63
 390:	0f 92       	push	r0
 392:	0b b6       	in	r0, 0x3b	; 59
 394:	0f 92       	push	r0
 396:	11 24       	eor	r1, r1
 398:	2f 93       	push	r18
 39a:	3f 93       	push	r19
 39c:	8f 93       	push	r24
 39e:	9f 93       	push	r25
 3a0:	ef 93       	push	r30
 3a2:	ff 93       	push	r31
/*
lo primeor que se encoentrara cunado se ingresa algo es esta ISR
*/
    ring_buffer *rx = &rx_buffers[0]; //terminal conectado con UART0
    char data = UDR0; //guardamos el dato que esta en el buffer en una varibale
 3a4:	90 91 c6 00 	lds	r25, 0x00C6

    uint8_t next_in = (rx->in_dx +1 ) % BUFFER_SIZE; //calculamos un valor 1 mas del in actual
 3a8:	80 91 90 03 	lds	r24, 0x0390
 3ac:	28 2f       	mov	r18, r24
 3ae:	30 e0       	ldi	r19, 0x00	; 0
 3b0:	2f 5f       	subi	r18, 0xFF	; 255
 3b2:	3f 4f       	sbci	r19, 0xFF	; 255
 3b4:	2f 73       	andi	r18, 0x3F	; 63
 3b6:	30 70       	andi	r19, 0x00	; 0
    //este nos funcionara para saber si aun no ha llegado al tome de la cola


    if(next_in != rx->out_dx){
 3b8:	80 91 91 03 	lds	r24, 0x0391
 3bc:	82 17       	cp	r24, r18
 3be:	41 f0       	breq	.+16     	; 0x3d0 <__vector_25+0x46>

        rx->buffer[rx->in_dx] = data;
 3c0:	e0 91 90 03 	lds	r30, 0x0390
 3c4:	f0 e0       	ldi	r31, 0x00	; 0
 3c6:	e0 5b       	subi	r30, 0xB0	; 176
 3c8:	fc 4f       	sbci	r31, 0xFC	; 252
 3ca:	90 83       	st	Z, r25
        rx->in_dx = next_in;
 3cc:	20 93 90 03 	sts	0x0390, r18
    }
}
 3d0:	ff 91       	pop	r31
 3d2:	ef 91       	pop	r30
 3d4:	9f 91       	pop	r25
 3d6:	8f 91       	pop	r24
 3d8:	3f 91       	pop	r19
 3da:	2f 91       	pop	r18
 3dc:	0f 90       	pop	r0
 3de:	0b be       	out	0x3b, r0	; 59
 3e0:	0f 90       	pop	r0
 3e2:	0f be       	out	0x3f, r0	; 63
 3e4:	0f 90       	pop	r0
 3e6:	1f 90       	pop	r1
 3e8:	18 95       	reti

000003ea <UART_putchar>:
//send
/*
lo que hace la funcion putchar seria enviar el caracter a la cola TX y hbaulutar la interrupcion UDRE

*/
void UART_putchar(uint8_t com, char data){
 3ea:	28 2f       	mov	r18, r24


    ring_buffer *tx = &tx_buffers[com]; //va a elegir sobre cual UART se mandara.
 3ec:	82 e4       	ldi	r24, 0x42	; 66
 3ee:	28 9f       	mul	r18, r24
 3f0:	f0 01       	movw	r30, r0
 3f2:	11 24       	eor	r1, r1
 3f4:	e8 5b       	subi	r30, 0xB8	; 184
 3f6:	fd 4f       	sbci	r31, 0xFD	; 253

    //calculamos cobre que indice esta in_dx esta actualmente.
    uint8_t next_int = (tx->in_dx +1 ) % BUFFER_SIZE;
 3f8:	e0 5c       	subi	r30, 0xC0	; 192
 3fa:	ff 4f       	sbci	r31, 0xFF	; 255
 3fc:	90 81       	ld	r25, Z
 3fe:	e0 54       	subi	r30, 0x40	; 64
 400:	f0 40       	sbci	r31, 0x00	; 0
 402:	9f 5f       	subi	r25, 0xFF	; 255
 404:	9f 73       	andi	r25, 0x3F	; 63

    /*
        lo que esta pasando es que esta esperando si el buffer esta llegno, como podemos saber si el buffer esta lleno,

    */
    while(next_int == tx->out_dx);
 406:	df 01       	movw	r26, r30
 408:	af 5b       	subi	r26, 0xBF	; 191
 40a:	bf 4f       	sbci	r27, 0xFF	; 255
 40c:	8c 91       	ld	r24, X
 40e:	98 17       	cp	r25, r24
 410:	e9 f3       	breq	.-6      	; 0x40c <UART_putchar+0x22>


    //una vez que se hayan liberados espapcios en el buffer ingresamos el sigueite dato

    tx->buffer[tx->in_dx] = data;
 412:	df 01       	movw	r26, r30
 414:	a0 5c       	subi	r26, 0xC0	; 192
 416:	bf 4f       	sbci	r27, 0xFF	; 255
 418:	8c 91       	ld	r24, X
 41a:	e8 0f       	add	r30, r24
 41c:	f1 1d       	adc	r31, r1
 41e:	60 83       	st	Z, r22
    tx->in_dx = next_int;
 420:	9c 93       	st	X, r25

    //habilitamos la interrupcion UDRE

    UART_reg_t *myUART = UART_offset[com];
 422:	e2 2f       	mov	r30, r18
 424:	f0 e0       	ldi	r31, 0x00	; 0
 426:	ee 0f       	add	r30, r30
 428:	ff 1f       	adc	r31, r31
 42a:	e0 5c       	subi	r30, 0xC0	; 192
 42c:	fd 4f       	sbci	r31, 0xFD	; 253
 42e:	01 90       	ld	r0, Z+
 430:	f0 81       	ld	r31, Z
 432:	e0 2d       	mov	r30, r0

    if(!(myUART->UCSRB & (1 << UDRIE0))){
 434:	81 81       	ldd	r24, Z+1	; 0x01
 436:	85 fd       	sbrc	r24, 5
 438:	04 c0       	rjmp	.+8      	; 0x442 <UART_putchar+0x58>
        myUART->UCSRB |= (1 << UDRIE0);
 43a:	81 81       	ldd	r24, Z+1	; 0x01
 43c:	80 62       	ori	r24, 0x20	; 32
 43e:	81 83       	std	Z+1, r24	; 0x01
 440:	08 95       	ret
    }else{
          UCSR0B &= ~(1 << UDRIE0); // Deshabilitar interrupción si no hay datos, para que no este pasando la interrupcion siempre
 442:	80 91 c1 00 	lds	r24, 0x00C1
 446:	8f 7d       	andi	r24, 0xDF	; 223
 448:	80 93 c1 00 	sts	0x00C1, r24
 44c:	08 95       	ret

0000044e <UART_available>:
// Received
//como saber si existen datos en la cola ciruclar, es sencillo esta vez, si el in_dx esta
//desplzado es que hay al menos 1 dato dentro
uint8_t UART_available(uint8_t com){

    ring_buffer *tx = &tx_buffers[com];
 44e:	92 e4       	ldi	r25, 0x42	; 66
 450:	89 9f       	mul	r24, r25
 452:	f0 01       	movw	r30, r0
 454:	11 24       	eor	r1, r1
 456:	e8 5b       	subi	r30, 0xB8	; 184
 458:	fd 4f       	sbci	r31, 0xFD	; 253

    return tx->in_dx != tx->out_dx ? 1:0;
 45a:	e0 5c       	subi	r30, 0xC0	; 192
 45c:	ff 4f       	sbci	r31, 0xFF	; 255
 45e:	91 91       	ld	r25, Z+
 460:	80 81       	ld	r24, Z
 462:	20 e0       	ldi	r18, 0x00	; 0
 464:	98 13       	cpse	r25, r24
 466:	21 e0       	ldi	r18, 0x01	; 1
}
 468:	82 2f       	mov	r24, r18
 46a:	08 95       	ret

0000046c <UART_getchar>:


/*

*/
char UART_getchar(uint8_t com ){
 46c:	cf 93       	push	r28
 46e:	df 93       	push	r29


    //este gecvhar sera para cualquier puerto

    ring_buffer *rx = &rx_buffers[com];
 470:	92 e4       	ldi	r25, 0x42	; 66
 472:	89 9f       	mul	r24, r25
 474:	f0 01       	movw	r30, r0
 476:	11 24       	eor	r1, r1
 478:	e0 5b       	subi	r30, 0xB0	; 176
 47a:	fc 4f       	sbci	r31, 0xFC	; 252

    while(rx->in_dx == rx->out_dx);
 47c:	ef 01       	movw	r28, r30
 47e:	c0 5c       	subi	r28, 0xC0	; 192
 480:	df 4f       	sbci	r29, 0xFF	; 255
 482:	df 01       	movw	r26, r30
 484:	af 5b       	subi	r26, 0xBF	; 191
 486:	bf 4f       	sbci	r27, 0xFF	; 255
 488:	98 81       	ld	r25, Y
 48a:	8c 91       	ld	r24, X
 48c:	98 17       	cp	r25, r24
 48e:	e1 f3       	breq	.-8      	; 0x488 <UART_getchar+0x1c>

    char data = rx->buffer[rx->out_dx];
 490:	8c 91       	ld	r24, X
 492:	e8 0f       	add	r30, r24
 494:	f1 1d       	adc	r31, r1
 496:	80 81       	ld	r24, Z

    rx->out_dx = (rx->out_dx + 1) % BUFFER_SIZE;
 498:	2c 91       	ld	r18, X
 49a:	30 e0       	ldi	r19, 0x00	; 0
 49c:	2f 5f       	subi	r18, 0xFF	; 255
 49e:	3f 4f       	sbci	r19, 0xFF	; 255
 4a0:	2f 73       	andi	r18, 0x3F	; 63
 4a2:	30 70       	andi	r19, 0x00	; 0
 4a4:	2c 93       	st	X, r18

    return data;
}
 4a6:	df 91       	pop	r29
 4a8:	cf 91       	pop	r28
 4aa:	08 95       	ret

000004ac <UART_puts>:


// Send
void UART_puts(uint8_t com, char *str)
{
 4ac:	1f 93       	push	r17
 4ae:	cf 93       	push	r28
 4b0:	df 93       	push	r29
 4b2:	18 2f       	mov	r17, r24
 4b4:	eb 01       	movw	r28, r22
 4b6:	04 c0       	rjmp	.+8      	; 0x4c0 <UART_puts+0x14>

    // TXn trasmitir el contenido
    while (*str != '\0')
    {
        // mientras haya contenido en el apuntador, que sea diferente a NULL
        UART_putchar(com, *str++);
 4b8:	21 96       	adiw	r28, 0x01	; 1
 4ba:	81 2f       	mov	r24, r17
 4bc:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
// Send
void UART_puts(uint8_t com, char *str)
{

    // TXn trasmitir el contenido
    while (*str != '\0')
 4c0:	68 81       	ld	r22, Y
 4c2:	66 23       	and	r22, r22
 4c4:	c9 f7       	brne	.-14     	; 0x4b8 <UART_puts+0xc>
    {
        // mientras haya contenido en el apuntador, que sea diferente a NULL
        UART_putchar(com, *str++);
    }
}
 4c6:	df 91       	pop	r29
 4c8:	cf 91       	pop	r28
 4ca:	1f 91       	pop	r17
 4cc:	08 95       	ret

000004ce <UART_gets>:


void UART_gets(uint8_t com, char *str)
{
 4ce:	ef 92       	push	r14
 4d0:	ff 92       	push	r15
 4d2:	0f 93       	push	r16
 4d4:	1f 93       	push	r17
 4d6:	cf 93       	push	r28
 4d8:	df 93       	push	r29
 4da:	f8 2e       	mov	r15, r24
 4dc:	eb 01       	movw	r28, r22
 4de:	00 e0       	ldi	r16, 0x00	; 0
 4e0:	57 c0       	rjmp	.+174    	; 0x590 <UART_gets+0xc2>
 4e2:	ee 24       	eor	r14, r14
 4e4:	e3 94       	inc	r14
    uint8_t i = 0;
    uint8_t dot_flag = 0; // Bandera para detectar punto

    while (1)
    {
        c = UART_getchar(com);
 4e6:	8f 2d       	mov	r24, r15
 4e8:	0e 94 36 02 	call	0x46c	; 0x46c <UART_getchar>
 4ec:	18 2f       	mov	r17, r24
        if (c == '\b')
 4ee:	88 30       	cpi	r24, 0x08	; 8
 4f0:	a1 f4       	brne	.+40     	; 0x51a <UART_gets+0x4c>
        {
            if (i > 0)
 4f2:	00 23       	and	r16, r16
 4f4:	c1 f3       	breq	.-16     	; 0x4e6 <UART_gets+0x18>
            {

                str[--i] = '\0'; // sustitumos el utlimo caracter con el nulo
 4f6:	01 50       	subi	r16, 0x01	; 1
 4f8:	fe 01       	movw	r30, r28
 4fa:	e0 0f       	add	r30, r16
 4fc:	f1 1d       	adc	r31, r1
 4fe:	10 82       	st	Z, r1
                UART_putchar(com, '\b');
 500:	8f 2d       	mov	r24, r15
 502:	68 e0       	ldi	r22, 0x08	; 8
 504:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
                UART_putchar(com, ' ');
 508:	8f 2d       	mov	r24, r15
 50a:	60 e2       	ldi	r22, 0x20	; 32
 50c:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
                UART_putchar(com, '\b');
 510:	8f 2d       	mov	r24, r15
 512:	68 e0       	ldi	r22, 0x08	; 8
 514:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
 518:	e6 cf       	rjmp	.-52     	; 0x4e6 <UART_gets+0x18>
            }

            continue; // si no hay nada que borrar o si hay algoq ue borrar sigue con el ciclo
        }

        UART_putchar(com, c);
 51a:	8f 2d       	mov	r24, r15
 51c:	61 2f       	mov	r22, r17
 51e:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>

        if (c == '\r' || c == '\n')
 522:	1d 30       	cpi	r17, 0x0D	; 13
 524:	11 f0       	breq	.+4      	; 0x52a <UART_gets+0x5c>
 526:	1a 30       	cpi	r17, 0x0A	; 10
 528:	91 f4       	brne	.+36     	; 0x54e <UART_gets+0x80>
        {
            // retorno de carro o salto de linea lo que quiere decir que se terminao de escribir el
            // texto actual.

            str[i] = '\0';           // caracter nulo denotando que la
 52a:	c0 0f       	add	r28, r16
 52c:	d1 1d       	adc	r29, r1
 52e:	18 82       	st	Y, r1
            UART_putchar(com, '\r'); // vuelve al inicio de la linea
 530:	8f 2d       	mov	r24, r15
 532:	6d e0       	ldi	r22, 0x0D	; 13
 534:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
            UART_putchar(com, '\n'); // salto de linea
 538:	8f 2d       	mov	r24, r15
 53a:	6a e0       	ldi	r22, 0x0A	; 10
 53c:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
            UART_putchar(com, '\b');
            UART_putchar(com, ' ');
            UART_putchar(com, '\b');
        }
    }
}
 540:	df 91       	pop	r29
 542:	cf 91       	pop	r28
 544:	1f 91       	pop	r17
 546:	0f 91       	pop	r16
 548:	ff 90       	pop	r15
 54a:	ef 90       	pop	r14
 54c:	08 95       	ret
            UART_putchar(com, '\r'); // vuelve al inicio de la linea
            UART_putchar(com, '\n'); // salto de linea
            break;                   // rompesmos el ciclo y a esperar que se vuelva a escribir algo
        }

        if (c == '.')
 54e:	1e 32       	cpi	r17, 0x2E	; 46
 550:	41 f2       	breq	.-112    	; 0x4e2 <UART_gets+0x14>
        {
            dot_flag = 1;
            continue; // No muestra el punto
        }

        if (dot_flag)
 552:	ee 20       	and	r14, r14
 554:	29 f0       	breq	.+10     	; 0x560 <UART_gets+0x92>
        {

            str[i++] = '\0'; // desoues de este punto ya no lo tomara en cuenta
 556:	fe 01       	movw	r30, r28
 558:	e0 0f       	add	r30, r16
 55a:	f1 1d       	adc	r31, r1
 55c:	10 82       	st	Z, r1
 55e:	0f 5f       	subi	r16, 0xFF	; 255
 560:	e0 2f       	mov	r30, r16
 562:	f0 e0       	ldi	r31, 0x00	; 0

        // para 20 caracteres, si no lo regresamos a 127



        if (i < 19)
 564:	03 31       	cpi	r16, 0x13	; 19
 566:	28 f4       	brcc	.+10     	; 0x572 <UART_gets+0xa4>
        {

            str[i++] = c;
 568:	ec 0f       	add	r30, r28
 56a:	fd 1f       	adc	r31, r29
 56c:	10 83       	st	Z, r17
 56e:	0f 5f       	subi	r16, 0xFF	; 255
 570:	0f c0       	rjmp	.+30     	; 0x590 <UART_gets+0xc2>
            // UART_putchar(com, c);
        }
        else
        {
            str[i] = '\0'; // sustitumos el utlimo caracter con el nulo
 572:	ec 0f       	add	r30, r28
 574:	fd 1f       	adc	r31, r29
 576:	10 82       	st	Z, r1
            UART_putchar(com, '\b');
 578:	8f 2d       	mov	r24, r15
 57a:	68 e0       	ldi	r22, 0x08	; 8
 57c:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
            UART_putchar(com, ' ');
 580:	8f 2d       	mov	r24, r15
 582:	60 e2       	ldi	r22, 0x20	; 32
 584:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
            UART_putchar(com, '\b');
 588:	8f 2d       	mov	r24, r15
 58a:	68 e0       	ldi	r22, 0x08	; 8
 58c:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
 590:	ee 24       	eor	r14, r14
 592:	a9 cf       	rjmp	.-174    	; 0x4e6 <UART_gets+0x18>

00000594 <UART_clrscr>:
}

//*****************************************************************************************************

// Escape sequences
UART_clrscr( uint8_t com ){
 594:	1f 93       	push	r17
 596:	18 2f       	mov	r17, r24

    UART_reg_t *myUART = UART_offset[com];

    UART_puts(com,"\x1B[2J"); //borra toda la pantalla
 598:	63 e2       	ldi	r22, 0x23	; 35
 59a:	72 e0       	ldi	r23, 0x02	; 2
 59c:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
    UART_puts(com,"\x1B[H"); // poen el curso al incio fila 1, columna 1
 5a0:	81 2f       	mov	r24, r17
 5a2:	68 e2       	ldi	r22, 0x28	; 40
 5a4:	72 e0       	ldi	r23, 0x02	; 2
 5a6:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>


}
 5aa:	1f 91       	pop	r17
 5ac:	08 95       	ret

000005ae <UART_setColor>:



UART_setColor(uint8_t com, uint8_t color){
 5ae:	0f 93       	push	r16
 5b0:	1f 93       	push	r17
 5b2:	18 2f       	mov	r17, r24
 5b4:	06 2f       	mov	r16, r22


    UART_puts(com,"\x1B["); //incio del comando espace
 5b6:	6c e2       	ldi	r22, 0x2C	; 44
 5b8:	72 e0       	ldi	r23, 0x02	; 2
 5ba:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>
    UART_putchar(com, '0'+(color/10));
 5be:	80 2f       	mov	r24, r16
 5c0:	6a e0       	ldi	r22, 0x0A	; 10
 5c2:	0e 94 ee 03 	call	0x7dc	; 0x7dc <__udivmodqi4>
 5c6:	68 2f       	mov	r22, r24
 5c8:	60 5d       	subi	r22, 0xD0	; 208
 5ca:	81 2f       	mov	r24, r17
 5cc:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
    UART_putchar(com,'0'+(color%10));
 5d0:	80 2f       	mov	r24, r16
 5d2:	6a e0       	ldi	r22, 0x0A	; 10
 5d4:	0e 94 ee 03 	call	0x7dc	; 0x7dc <__udivmodqi4>
 5d8:	90 5d       	subi	r25, 0xD0	; 208
 5da:	81 2f       	mov	r24, r17
 5dc:	69 2f       	mov	r22, r25
 5de:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
    UART_putchar(com,'m'); //final del comando
 5e2:	81 2f       	mov	r24, r17
 5e4:	6d e6       	ldi	r22, 0x6D	; 109
 5e6:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
 }
 5ea:	1f 91       	pop	r17
 5ec:	0f 91       	pop	r16
 5ee:	08 95       	ret

000005f0 <UART_putnum>:

 void UART_putnum(uint8_t com, uint8_t num){
 5f0:	0f 93       	push	r16
 5f2:	1f 93       	push	r17
 5f4:	08 2f       	mov	r16, r24
 5f6:	16 2f       	mov	r17, r22

    if(num >= 100){
 5f8:	64 36       	cpi	r22, 0x64	; 100
 5fa:	70 f0       	brcs	.+28     	; 0x618 <UART_putnum+0x28>
        UART_putchar(com, '0'+(num/100));
 5fc:	86 2f       	mov	r24, r22
 5fe:	64 e6       	ldi	r22, 0x64	; 100
 600:	0e 94 ee 03 	call	0x7dc	; 0x7dc <__udivmodqi4>
 604:	68 2f       	mov	r22, r24
 606:	60 5d       	subi	r22, 0xD0	; 208
 608:	80 2f       	mov	r24, r16
 60a:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
        num%=100;
 60e:	81 2f       	mov	r24, r17
 610:	64 e6       	ldi	r22, 0x64	; 100
 612:	0e 94 ee 03 	call	0x7dc	; 0x7dc <__udivmodqi4>
 616:	19 2f       	mov	r17, r25
    }
    if(num>=10){
 618:	1a 30       	cpi	r17, 0x0A	; 10
 61a:	70 f0       	brcs	.+28     	; 0x638 <UART_putnum+0x48>
        UART_putchar(com, '0'+(num/10));
 61c:	81 2f       	mov	r24, r17
 61e:	6a e0       	ldi	r22, 0x0A	; 10
 620:	0e 94 ee 03 	call	0x7dc	; 0x7dc <__udivmodqi4>
 624:	68 2f       	mov	r22, r24
 626:	60 5d       	subi	r22, 0xD0	; 208
 628:	80 2f       	mov	r24, r16
 62a:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
        num%=10;
 62e:	81 2f       	mov	r24, r17
 630:	6a e0       	ldi	r22, 0x0A	; 10
 632:	0e 94 ee 03 	call	0x7dc	; 0x7dc <__udivmodqi4>
 636:	19 2f       	mov	r17, r25
    }

    UART_putchar(com,'0'+num);
 638:	10 5d       	subi	r17, 0xD0	; 208
 63a:	80 2f       	mov	r24, r16
 63c:	61 2f       	mov	r22, r17
 63e:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>

}
 642:	1f 91       	pop	r17
 644:	0f 91       	pop	r16
 646:	08 95       	ret

00000648 <UART_gotoxy>:


UART_gotoxy(uint8_t com, uint8_t x, uint8_t y){
 648:	ff 92       	push	r15
 64a:	0f 93       	push	r16
 64c:	1f 93       	push	r17
 64e:	18 2f       	mov	r17, r24
 650:	f6 2e       	mov	r15, r22
 652:	04 2f       	mov	r16, r20

    UART_puts(com,"\x1B["); //inicio de la secuencia de esapce
 654:	6c e2       	ldi	r22, 0x2C	; 44
 656:	72 e0       	ldi	r23, 0x02	; 2
 658:	0e 94 56 02 	call	0x4ac	; 0x4ac <UART_puts>

    UART_putnum(com,y+1); //convertir a caracter
 65c:	0f 5f       	subi	r16, 0xFF	; 255
 65e:	81 2f       	mov	r24, r17
 660:	60 2f       	mov	r22, r16
 662:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <UART_putnum>
    UART_putchar(com,';');
 666:	81 2f       	mov	r24, r17
 668:	6b e3       	ldi	r22, 0x3B	; 59
 66a:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>
    UART_putnum(com,x+1);
 66e:	f3 94       	inc	r15
 670:	81 2f       	mov	r24, r17
 672:	6f 2d       	mov	r22, r15
 674:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <UART_putnum>
    UART_putchar(com,'H'); //final de la secuencia
 678:	81 2f       	mov	r24, r17
 67a:	68 e4       	ldi	r22, 0x48	; 72
 67c:	0e 94 f5 01 	call	0x3ea	; 0x3ea <UART_putchar>

}
 680:	1f 91       	pop	r17
 682:	0f 91       	pop	r16
 684:	ff 90       	pop	r15
 686:	08 95       	ret

00000688 <itoa>:

//**************************************************************************************************


// Utils
void itoa(uint16_t number, char* str, uint8_t base){
 688:	0f 93       	push	r16
 68a:	1f 93       	push	r17
 68c:	df 93       	push	r29
 68e:	cf 93       	push	r28
 690:	cd b7       	in	r28, 0x3d	; 61
 692:	de b7       	in	r29, 0x3e	; 62
 694:	a1 97       	sbiw	r28, 0x21	; 33
 696:	0f b6       	in	r0, 0x3f	; 63
 698:	f8 94       	cli
 69a:	de bf       	out	0x3e, r29	; 62
 69c:	0f be       	out	0x3f, r0	; 63
 69e:	cd bf       	out	0x3d, r28	; 61

    char *aux= str;

    if(base == 16){
 6a0:	40 31       	cpi	r20, 0x10	; 16
 6a2:	a1 f5       	brne	.+104    	; 0x70c <itoa+0x84>

        //asignamos un arreglo con las representaciones de los numero HEX en ASCI
        char hex[] = "0123456789ABCDEF";
 6a4:	de 01       	movw	r26, r28
 6a6:	51 96       	adiw	r26, 0x11	; 17
 6a8:	ef e2       	ldi	r30, 0x2F	; 47
 6aa:	f2 e0       	ldi	r31, 0x02	; 2
 6ac:	21 e1       	ldi	r18, 0x11	; 17
 6ae:	01 90       	ld	r0, Z+
 6b0:	0d 92       	st	X+, r0
 6b2:	21 50       	subi	r18, 0x01	; 1
 6b4:	e1 f7       	brne	.-8      	; 0x6ae <itoa+0x26>
        uint8_t index = 0;
        uint16_t temp = number; //hacemos un backup de number para trbajar con el y no pereder el valor original

        // Manejar el caso cuando el número es 0
        if (temp == 0) {
 6b6:	00 97       	sbiw	r24, 0x00	; 0
 6b8:	69 f1       	breq	.+90     	; 0x714 <itoa+0x8c>
            aux[index++] = '0';
            aux[index] = '\0';
            return;
 6ba:	9c 01       	movw	r18, r24
 6bc:	90 e0       	ldi	r25, 0x00	; 0

        char buffer[16];
        uint8_t buf_idx = 0;

        while (temp > 0) {
            buffer[buf_idx++] = hex[temp % base];
 6be:	ae 01       	movw	r20, r28
 6c0:	4f 5f       	subi	r20, 0xFF	; 255
 6c2:	5f 4f       	sbci	r21, 0xFF	; 255
 6c4:	8e 01       	movw	r16, r28
 6c6:	0f 5e       	subi	r16, 0xEF	; 239
 6c8:	1f 4f       	sbci	r17, 0xFF	; 255
 6ca:	fa 01       	movw	r30, r20
 6cc:	e9 0f       	add	r30, r25
 6ce:	f1 1d       	adc	r31, r1
 6d0:	d9 01       	movw	r26, r18
 6d2:	af 70       	andi	r26, 0x0F	; 15
 6d4:	b0 70       	andi	r27, 0x00	; 0
 6d6:	a0 0f       	add	r26, r16
 6d8:	b1 1f       	adc	r27, r17
 6da:	8c 91       	ld	r24, X
 6dc:	80 83       	st	Z, r24
 6de:	9f 5f       	subi	r25, 0xFF	; 255
            temp /= base;
 6e0:	f4 e0       	ldi	r31, 0x04	; 4
 6e2:	36 95       	lsr	r19
 6e4:	27 95       	ror	r18
 6e6:	fa 95       	dec	r31
 6e8:	e1 f7       	brne	.-8      	; 0x6e2 <itoa+0x5a>
        }

        char buffer[16];
        uint8_t buf_idx = 0;

        while (temp > 0) {
 6ea:	21 15       	cp	r18, r1
 6ec:	31 05       	cpc	r19, r1
 6ee:	69 f7       	brne	.-38     	; 0x6ca <itoa+0x42>
 6f0:	fa 01       	movw	r30, r20
 6f2:	e9 0f       	add	r30, r25
 6f4:	f1 1d       	adc	r31, r1
 6f6:	db 01       	movw	r26, r22
 6f8:	02 c0       	rjmp	.+4      	; 0x6fe <itoa+0x76>
            buffer[buf_idx++] = hex[temp % base];
            temp /= base;
        }

        for (int i = buf_idx - 1; i >= 0; i--) {
            aux[index++] = buffer[i];
 6fa:	80 81       	ld	r24, Z
 6fc:	8d 93       	st	X+, r24
 6fe:	31 97       	sbiw	r30, 0x01	; 1
        while (temp > 0) {
            buffer[buf_idx++] = hex[temp % base];
            temp /= base;
        }

        for (int i = buf_idx - 1; i >= 0; i--) {
 700:	ec 17       	cp	r30, r28
 702:	fd 07       	cpc	r31, r29
 704:	d1 f7       	brne	.-12     	; 0x6fa <itoa+0x72>
            aux[index++] = buffer[i];
        }
        aux[index] = '\0'; // Terminar con nulo
 706:	69 0f       	add	r22, r25
 708:	71 1d       	adc	r23, r1
 70a:	3d c0       	rjmp	.+122    	; 0x786 <itoa+0xfe>

    }


    else if(base == 2){
 70c:	42 30       	cpi	r20, 0x02	; 2
 70e:	e9 f5       	brne	.+122    	; 0x78a <itoa+0x102>
        char buffer[17]; //tiene tamaño 16 porque el number es un numero de 16 bits, el caracter nulo
        //se agrega despues en el apuntador

        uint8_t buf_idx=0;

        if(number ==0){
 710:	00 97       	sbiw	r24, 0x00	; 0
 712:	29 f4       	brne	.+10     	; 0x71e <itoa+0x96>

            aux[index++] = '0';
 714:	80 e3       	ldi	r24, 0x30	; 48
 716:	fb 01       	movw	r30, r22
 718:	80 83       	st	Z, r24
            aux[index] = '\0';
 71a:	11 82       	std	Z+1, r1	; 0x01
 71c:	36 c0       	rjmp	.+108    	; 0x78a <itoa+0x102>
            return;
 71e:	20 e0       	ldi	r18, 0x00	; 0
        }

        while(temp > 0){

            buffer[buf_idx++]= (temp%2)?'1':'0';
 720:	ae 01       	movw	r20, r28
 722:	4f 5e       	subi	r20, 0xEF	; 239
 724:	5f 4f       	sbci	r21, 0xFF	; 255
 726:	80 fd       	sbrc	r24, 0
 728:	02 c0       	rjmp	.+4      	; 0x72e <itoa+0xa6>
 72a:	30 e3       	ldi	r19, 0x30	; 48
 72c:	01 c0       	rjmp	.+2      	; 0x730 <itoa+0xa8>
 72e:	31 e3       	ldi	r19, 0x31	; 49
 730:	fa 01       	movw	r30, r20
 732:	e2 0f       	add	r30, r18
 734:	f1 1d       	adc	r31, r1
 736:	30 83       	st	Z, r19
 738:	2f 5f       	subi	r18, 0xFF	; 255
            temp/=2;
 73a:	96 95       	lsr	r25
 73c:	87 95       	ror	r24
            aux[index++] = '0';
            aux[index] = '\0';
            return;
        }

        while(temp > 0){
 73e:	00 97       	sbiw	r24, 0x00	; 0
 740:	91 f7       	brne	.-28     	; 0x726 <itoa+0x9e>
 742:	06 c0       	rjmp	.+12     	; 0x750 <itoa+0xc8>
            temp/=2;
        }
        //rellenar con ceros a la izqueirda

        while(buf_idx < 16){
            buffer[buf_idx++]= '0';
 744:	fc 01       	movw	r30, r24
 746:	e2 0f       	add	r30, r18
 748:	f1 1d       	adc	r31, r1
 74a:	30 83       	st	Z, r19
 74c:	2f 5f       	subi	r18, 0xFF	; 255
 74e:	03 c0       	rjmp	.+6      	; 0x756 <itoa+0xce>
 750:	ce 01       	movw	r24, r28
 752:	41 96       	adiw	r24, 0x11	; 17
 754:	30 e3       	ldi	r19, 0x30	; 48
            buffer[buf_idx++]= (temp%2)?'1':'0';
            temp/=2;
        }
        //rellenar con ceros a la izqueirda

        while(buf_idx < 16){
 756:	20 31       	cpi	r18, 0x10	; 16
 758:	a8 f3       	brcs	.-22     	; 0x744 <itoa+0xbc>
            buffer[buf_idx++]= '0';
        }

        index=0;

        for(int8_t i = buf_idx-1 ; i >= 0 ; i--){
 75a:	42 2f       	mov	r20, r18
 75c:	41 50       	subi	r20, 0x01	; 1
 75e:	a4 2f       	mov	r26, r20
 760:	bb 27       	eor	r27, r27
 762:	a7 fd       	sbrc	r26, 7
 764:	b0 95       	com	r27
 766:	a8 0f       	add	r26, r24
 768:	b9 1f       	adc	r27, r25
 76a:	56 2f       	mov	r21, r22
 76c:	cb 01       	movw	r24, r22
 76e:	fc 01       	movw	r30, r24
 770:	04 c0       	rjmp	.+8      	; 0x77a <itoa+0xf2>
            aux[index++] = buffer[i];
 772:	8c 91       	ld	r24, X
 774:	81 93       	st	Z+, r24
            buffer[buf_idx++]= '0';
        }

        index=0;

        for(int8_t i = buf_idx-1 ; i >= 0 ; i--){
 776:	41 50       	subi	r20, 0x01	; 1
 778:	11 97       	sbiw	r26, 0x01	; 1
 77a:	8e 2f       	mov	r24, r30
 77c:	85 1b       	sub	r24, r21
 77e:	47 ff       	sbrs	r20, 7
 780:	f8 cf       	rjmp	.-16     	; 0x772 <itoa+0xea>
            aux[index++] = buffer[i];
        }

        aux[index]='\0';
 782:	68 0f       	add	r22, r24
 784:	71 1d       	adc	r23, r1
 786:	fb 01       	movw	r30, r22
 788:	10 82       	st	Z, r1

    }

}
 78a:	a1 96       	adiw	r28, 0x21	; 33
 78c:	0f b6       	in	r0, 0x3f	; 63
 78e:	f8 94       	cli
 790:	de bf       	out	0x3e, r29	; 62
 792:	0f be       	out	0x3f, r0	; 63
 794:	cd bf       	out	0x3d, r28	; 61
 796:	cf 91       	pop	r28
 798:	df 91       	pop	r29
 79a:	1f 91       	pop	r17
 79c:	0f 91       	pop	r16
 79e:	08 95       	ret

000007a0 <atoi>:



uint16_t atoi(char *str) {
 7a0:	fc 01       	movw	r30, r24
 7a2:	20 e0       	ldi	r18, 0x00	; 0
 7a4:	30 e0       	ldi	r19, 0x00	; 0
 7a6:	15 c0       	rjmp	.+42     	; 0x7d2 <atoi+0x32>
    uint16_t result = 0;
    while (*str != '\0') {
        if (*str >= '0' && *str <= '9') {
 7a8:	84 2f       	mov	r24, r20
 7aa:	80 53       	subi	r24, 0x30	; 48
 7ac:	8a 30       	cpi	r24, 0x0A	; 10
 7ae:	80 f4       	brcc	.+32     	; 0x7d0 <atoi+0x30>
            result = result * 10 + (*str - '0');
 7b0:	c9 01       	movw	r24, r18
 7b2:	b3 e0       	ldi	r27, 0x03	; 3
 7b4:	88 0f       	add	r24, r24
 7b6:	99 1f       	adc	r25, r25
 7b8:	ba 95       	dec	r27
 7ba:	e1 f7       	brne	.-8      	; 0x7b4 <atoi+0x14>
 7bc:	22 0f       	add	r18, r18
 7be:	33 1f       	adc	r19, r19
 7c0:	82 0f       	add	r24, r18
 7c2:	93 1f       	adc	r25, r19
 7c4:	24 2f       	mov	r18, r20
 7c6:	30 e0       	ldi	r19, 0x00	; 0
 7c8:	20 53       	subi	r18, 0x30	; 48
 7ca:	30 40       	sbci	r19, 0x00	; 0
 7cc:	28 0f       	add	r18, r24
 7ce:	39 1f       	adc	r19, r25
        }
        str++;
 7d0:	31 96       	adiw	r30, 0x01	; 1



uint16_t atoi(char *str) {
    uint16_t result = 0;
    while (*str != '\0') {
 7d2:	40 81       	ld	r20, Z
 7d4:	44 23       	and	r20, r20
 7d6:	41 f7       	brne	.-48     	; 0x7a8 <atoi+0x8>
            result = result * 10 + (*str - '0');
        }
        str++;
    }
    return result;
}
 7d8:	c9 01       	movw	r24, r18
 7da:	08 95       	ret

000007dc <__udivmodqi4>:
 7dc:	99 1b       	sub	r25, r25
 7de:	79 e0       	ldi	r23, 0x09	; 9
 7e0:	04 c0       	rjmp	.+8      	; 0x7ea <__udivmodqi4_ep>

000007e2 <__udivmodqi4_loop>:
 7e2:	99 1f       	adc	r25, r25
 7e4:	96 17       	cp	r25, r22
 7e6:	08 f0       	brcs	.+2      	; 0x7ea <__udivmodqi4_ep>
 7e8:	96 1b       	sub	r25, r22

000007ea <__udivmodqi4_ep>:
 7ea:	88 1f       	adc	r24, r24
 7ec:	7a 95       	dec	r23
 7ee:	c9 f7       	brne	.-14     	; 0x7e2 <__udivmodqi4_loop>
 7f0:	80 95       	com	r24
 7f2:	08 95       	ret

000007f4 <__udivmodsi4>:
 7f4:	a1 e2       	ldi	r26, 0x21	; 33
 7f6:	1a 2e       	mov	r1, r26
 7f8:	aa 1b       	sub	r26, r26
 7fa:	bb 1b       	sub	r27, r27
 7fc:	fd 01       	movw	r30, r26
 7fe:	0d c0       	rjmp	.+26     	; 0x81a <__udivmodsi4_ep>

00000800 <__udivmodsi4_loop>:
 800:	aa 1f       	adc	r26, r26
 802:	bb 1f       	adc	r27, r27
 804:	ee 1f       	adc	r30, r30
 806:	ff 1f       	adc	r31, r31
 808:	a2 17       	cp	r26, r18
 80a:	b3 07       	cpc	r27, r19
 80c:	e4 07       	cpc	r30, r20
 80e:	f5 07       	cpc	r31, r21
 810:	20 f0       	brcs	.+8      	; 0x81a <__udivmodsi4_ep>
 812:	a2 1b       	sub	r26, r18
 814:	b3 0b       	sbc	r27, r19
 816:	e4 0b       	sbc	r30, r20
 818:	f5 0b       	sbc	r31, r21

0000081a <__udivmodsi4_ep>:
 81a:	66 1f       	adc	r22, r22
 81c:	77 1f       	adc	r23, r23
 81e:	88 1f       	adc	r24, r24
 820:	99 1f       	adc	r25, r25
 822:	1a 94       	dec	r1
 824:	69 f7       	brne	.-38     	; 0x800 <__udivmodsi4_loop>
 826:	60 95       	com	r22
 828:	70 95       	com	r23
 82a:	80 95       	com	r24
 82c:	90 95       	com	r25
 82e:	9b 01       	movw	r18, r22
 830:	ac 01       	movw	r20, r24
 832:	bd 01       	movw	r22, r26
 834:	cf 01       	movw	r24, r30
 836:	08 95       	ret

00000838 <_exit>:
 838:	f8 94       	cli

0000083a <__stop_program>:
 83a:	ff cf       	rjmp	.-2      	; 0x83a <__stop_program>
