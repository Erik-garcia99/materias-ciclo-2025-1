
PROYECTO_ejecucion_AVR.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800200  0000043e  000004b2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000043e  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .debug_aranges 00000040  00000000  00000000  000004d2  2**0
                  CONTENTS, READONLY, DEBUGGING
  3 .debug_pubnames 0000009a  00000000  00000000  00000512  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_info   00000654  00000000  00000000  000005ac  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_abbrev 00000250  00000000  00000000  00000c00  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   000003b4  00000000  00000000  00000e50  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000090  00000000  00000000  00001204  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_str    000001b5  00000000  00000000  00001294  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_loc    000003ec  00000000  00000000  00001449  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000090  00000000  00000000  00001835  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
   c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  10:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  14:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  18:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  1c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  20:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  24:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  28:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  2c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  30:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  34:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  38:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  3c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  40:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  44:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  48:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  4c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  50:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  54:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  58:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  5c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  60:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  64:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  68:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  6c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  70:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  74:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  78:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  7c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  80:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  84:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  88:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  8c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  90:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  94:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  98:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  9c:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  a8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  ac:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  b8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  bc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  c8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  cc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d4:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  d8:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  dc:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>
  e0:	0c 94 8b 00 	jmp	0x116	; 0x116 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	ee e3       	ldi	r30, 0x3E	; 62
  fc:	f4 e0       	ldi	r31, 0x04	; 4
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a0 32       	cpi	r26, 0x20	; 32
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>
 10e:	0e 94 8d 00 	call	0x11a	; 0x11a <main>
 112:	0c 94 1d 02 	jmp	0x43a	; 0x43a <_exit>

00000116 <__bad_interrupt>:
 116:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000011a <main>:




int main(void)
{
 11a:	ef 92       	push	r14
 11c:	ff 92       	push	r15
 11e:	0f 93       	push	r16
 120:	1f 93       	push	r17
 122:	df 93       	push	r29
 124:	cf 93       	push	r28
 126:	cd b7       	in	r28, 0x3d	; 61
 128:	de b7       	in	r29, 0x3e	; 62
 12a:	a8 97       	sbiw	r28, 0x28	; 40
 12c:	0f b6       	in	r0, 0x3f	; 63
 12e:	f8 94       	cli
 130:	de bf       	out	0x3e, r29	; 62
 132:	0f be       	out	0x3f, r0	; 63
 134:	cd bf       	out	0x3d, r28	; 61

    char cad[cantidad];
    char cadUART3[cantidad];

    //comunicacion con teraterm
    UART_init(0,12345,1,2,8);
 136:	80 e0       	ldi	r24, 0x00	; 0
 138:	49 e3       	ldi	r20, 0x39	; 57
 13a:	50 e3       	ldi	r21, 0x30	; 48
 13c:	60 e0       	ldi	r22, 0x00	; 0
 13e:	70 e0       	ldi	r23, 0x00	; 0
 140:	21 e0       	ldi	r18, 0x01	; 1
 142:	02 e0       	ldi	r16, 0x02	; 2
 144:	98 e0       	ldi	r25, 0x08	; 8
 146:	e9 2e       	mov	r14, r25
 148:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <UART_init>
    UART_init(2,115200,0,1,8);
 14c:	82 e0       	ldi	r24, 0x02	; 2
 14e:	40 e0       	ldi	r20, 0x00	; 0
 150:	52 ec       	ldi	r21, 0xC2	; 194
 152:	61 e0       	ldi	r22, 0x01	; 1
 154:	70 e0       	ldi	r23, 0x00	; 0
 156:	20 e0       	ldi	r18, 0x00	; 0
 158:	01 e0       	ldi	r16, 0x01	; 1
 15a:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <UART_init>
    UART_init(3,115200,0,1,8);
 15e:	83 e0       	ldi	r24, 0x03	; 3
 160:	40 e0       	ldi	r20, 0x00	; 0
 162:	52 ec       	ldi	r21, 0xC2	; 194
 164:	61 e0       	ldi	r22, 0x01	; 1
 166:	70 e0       	ldi	r23, 0x00	; 0
 168:	20 e0       	ldi	r18, 0x00	; 0
 16a:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <UART_init>

        UART_getchar(0);

        UART_puts(0,"introduce un numero:");

        UART_gets(0,cad);
 16e:	7e 01       	movw	r14, r28
 170:	08 94       	sec
 172:	e1 1c       	adc	r14, r1
 174:	f1 1c       	adc	r15, r1

        UART_puts(2,cad);
        UART_puts(2,"\r");
        UART_gets(3,cadUART3);
 176:	8e 01       	movw	r16, r28
 178:	0b 5e       	subi	r16, 0xEB	; 235
 17a:	1f 4f       	sbci	r17, 0xFF	; 255
    UART_init(2,115200,0,1,8);
    UART_init(3,115200,0,1,8);

    while(1){

        UART_getchar(0);
 17c:	80 e0       	ldi	r24, 0x00	; 0
 17e:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <UART_getchar>

        UART_puts(0,"introduce un numero:");
 182:	80 e0       	ldi	r24, 0x00	; 0
 184:	60 e0       	ldi	r22, 0x00	; 0
 186:	72 e0       	ldi	r23, 0x02	; 2
 188:	0e 94 38 01 	call	0x270	; 0x270 <UART_puts>

        UART_gets(0,cad);
 18c:	80 e0       	ldi	r24, 0x00	; 0
 18e:	b7 01       	movw	r22, r14
 190:	0e 94 78 01 	call	0x2f0	; 0x2f0 <UART_gets>

        UART_puts(2,cad);
 194:	82 e0       	ldi	r24, 0x02	; 2
 196:	b7 01       	movw	r22, r14
 198:	0e 94 38 01 	call	0x270	; 0x270 <UART_puts>
        UART_puts(2,"\r");
 19c:	82 e0       	ldi	r24, 0x02	; 2
 19e:	65 e1       	ldi	r22, 0x15	; 21
 1a0:	72 e0       	ldi	r23, 0x02	; 2
 1a2:	0e 94 38 01 	call	0x270	; 0x270 <UART_puts>
        UART_gets(3,cadUART3);
 1a6:	83 e0       	ldi	r24, 0x03	; 3
 1a8:	b8 01       	movw	r22, r16
 1aa:	0e 94 78 01 	call	0x2f0	; 0x2f0 <UART_gets>

        UART_puts(0,cadUART3);
 1ae:	80 e0       	ldi	r24, 0x00	; 0
 1b0:	b8 01       	movw	r22, r16
 1b2:	0e 94 38 01 	call	0x270	; 0x270 <UART_puts>
 1b6:	e2 cf       	rjmp	.-60     	; 0x17c <main+0x62>

000001b8 <UART_init>:

};



void UART_init(uint8_t com,uint32_t BOUD, uint8_t parity, uint8_t stop, uint8_t ch_size){
 1b8:	af 92       	push	r10
 1ba:	bf 92       	push	r11
 1bc:	cf 92       	push	r12
 1be:	df 92       	push	r13
 1c0:	ef 92       	push	r14
 1c2:	0f 93       	push	r16
 1c4:	cf 93       	push	r28
 1c6:	df 93       	push	r29
 1c8:	5a 01       	movw	r10, r20
 1ca:	6b 01       	movw	r12, r22
 1cc:	9e 2d       	mov	r25, r14

    UART_reg_t *myUART = UART_offset[com];
 1ce:	e8 2f       	mov	r30, r24
 1d0:	f0 e0       	ldi	r31, 0x00	; 0
 1d2:	ee 0f       	add	r30, r30
 1d4:	ff 1f       	adc	r31, r31
 1d6:	e8 5e       	subi	r30, 0xE8	; 232
 1d8:	fd 4f       	sbci	r31, 0xFD	; 253
 1da:	c0 81       	ld	r28, Z
 1dc:	d1 81       	ldd	r29, Z+1	; 0x01


    //habilitamspo RX y TX del UART que estemos usando con myUART


    myUART->UCSRB |= (1<<RXEN0) | (1<<TXEN0);
 1de:	89 81       	ldd	r24, Y+1	; 0x01
 1e0:	88 61       	ori	r24, 0x18	; 24
 1e2:	89 83       	std	Y+1, r24	; 0x01
    // 2 -> PAR even


    uint8_t parity_mode= 0;

    switch(parity){
 1e4:	21 30       	cpi	r18, 0x01	; 1
 1e6:	19 f0       	breq	.+6      	; 0x1ee <UART_init+0x36>
 1e8:	22 30       	cpi	r18, 0x02	; 2
 1ea:	19 f4       	brne	.+6      	; 0x1f2 <UART_init+0x3a>
 1ec:	04 c0       	rjmp	.+8      	; 0x1f6 <UART_init+0x3e>
 1ee:	73 e0       	ldi	r23, 0x03	; 3
 1f0:	03 c0       	rjmp	.+6      	; 0x1f8 <UART_init+0x40>
 1f2:	70 e0       	ldi	r23, 0x00	; 0
 1f4:	01 c0       	rjmp	.+2      	; 0x1f8 <UART_init+0x40>
 1f6:	72 e0       	ldi	r23, 0x02	; 2
    uint8_t stop_bit = (stop == 1) ? 0:1;

    //solo nos ocuparemos de hasta 8 bits
    uint8_t character =0;

    switch(ch_size){
 1f8:	97 30       	cpi	r25, 0x07	; 7
 1fa:	41 f0       	breq	.+16     	; 0x20c <UART_init+0x54>
 1fc:	98 30       	cpi	r25, 0x08	; 8
 1fe:	41 f0       	breq	.+16     	; 0x210 <UART_init+0x58>
 200:	96 30       	cpi	r25, 0x06	; 6
 202:	11 f4       	brne	.+4      	; 0x208 <UART_init+0x50>
 204:	21 e0       	ldi	r18, 0x01	; 1
 206:	05 c0       	rjmp	.+10     	; 0x212 <UART_init+0x5a>
 208:	20 e0       	ldi	r18, 0x00	; 0
 20a:	03 c0       	rjmp	.+6      	; 0x212 <UART_init+0x5a>
 20c:	22 e0       	ldi	r18, 0x02	; 2
 20e:	01 c0       	rjmp	.+2      	; 0x212 <UART_init+0x5a>
        case 5:
            character = 0; break;

        case 6 : character = 1; break;

        case 7: character = 2; break;
 210:	23 e0       	ldi	r18, 0x03	; 3
        case 8: character = 3; break;

    }


    myUART->UCSRC |= (parity_mode << UPM00) | (stop_bit<<USBS0) | (character << UCSZ00);
 212:	6a 81       	ldd	r22, Y+2	; 0x02
 214:	80 e0       	ldi	r24, 0x00	; 0
 216:	90 e0       	ldi	r25, 0x00	; 0
 218:	01 30       	cpi	r16, 0x01	; 1
 21a:	11 f0       	breq	.+4      	; 0x220 <UART_init+0x68>
 21c:	81 e0       	ldi	r24, 0x01	; 1
 21e:	90 e0       	ldi	r25, 0x00	; 0
 220:	33 e0       	ldi	r19, 0x03	; 3
 222:	88 0f       	add	r24, r24
 224:	99 1f       	adc	r25, r25
 226:	3a 95       	dec	r19
 228:	e1 f7       	brne	.-8      	; 0x222 <UART_init+0x6a>
 22a:	68 2b       	or	r22, r24
 22c:	72 95       	swap	r23
 22e:	70 7f       	andi	r23, 0xF0	; 240
 230:	76 2b       	or	r23, r22
 232:	22 0f       	add	r18, r18
 234:	27 2b       	or	r18, r23
 236:	2a 83       	std	Y+2, r18	; 0x02

    //ahora toca seleccionr a UBRR el cual es con la forumual

    uint16_t UBRR_value = (FOSC / (16 *(BOUD))) - 1;

    myUART->UBRR = UBRR_value;
 238:	84 e0       	ldi	r24, 0x04	; 4
 23a:	aa 0c       	add	r10, r10
 23c:	bb 1c       	adc	r11, r11
 23e:	cc 1c       	adc	r12, r12
 240:	dd 1c       	adc	r13, r13
 242:	8a 95       	dec	r24
 244:	d1 f7       	brne	.-12     	; 0x23a <UART_init+0x82>
 246:	60 e0       	ldi	r22, 0x00	; 0
 248:	74 e2       	ldi	r23, 0x24	; 36
 24a:	84 ef       	ldi	r24, 0xF4	; 244
 24c:	90 e0       	ldi	r25, 0x00	; 0
 24e:	a6 01       	movw	r20, r12
 250:	95 01       	movw	r18, r10
 252:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <__udivmodsi4>
 256:	21 50       	subi	r18, 0x01	; 1
 258:	30 40       	sbci	r19, 0x00	; 0
 25a:	3d 83       	std	Y+5, r19	; 0x05
 25c:	2c 83       	std	Y+4, r18	; 0x04
}
 25e:	df 91       	pop	r29
 260:	cf 91       	pop	r28
 262:	0f 91       	pop	r16
 264:	ef 90       	pop	r14
 266:	df 90       	pop	r13
 268:	cf 90       	pop	r12
 26a:	bf 90       	pop	r11
 26c:	af 90       	pop	r10
 26e:	08 95       	ret

00000270 <UART_puts>:
//funciones para trasnmitir


//la funcion de puts solo envia a putchar lo que se quiere enviar

void UART_puts(uint8_t com, char *str){
 270:	cf 93       	push	r28
 272:	df 93       	push	r29
 274:	eb 01       	movw	r28, r22



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 276:	e8 2f       	mov	r30, r24
 278:	f0 e0       	ldi	r31, 0x00	; 0
 27a:	ee 0f       	add	r30, r30
 27c:	ff 1f       	adc	r31, r31
 27e:	e8 5e       	subi	r30, 0xE8	; 232
 280:	fd 4f       	sbci	r31, 0xFD	; 253
 282:	08 c0       	rjmp	.+16     	; 0x294 <UART_puts+0x24>
 284:	a0 81       	ld	r26, Z
 286:	b1 81       	ldd	r27, Z+1	; 0x01

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 288:	8c 91       	ld	r24, X
 28a:	85 ff       	sbrs	r24, 5
 28c:	fd cf       	rjmp	.-6      	; 0x288 <UART_puts+0x18>


    myUART->UDR = data;
 28e:	16 96       	adiw	r26, 0x06	; 6
 290:	9c 93       	st	X, r25

    //indicamos el caracter cero como caracter que finaliza una cadena
    while(*str != '\0'){

        UART_putchar(com, *str);
        *str++;
 292:	21 96       	adiw	r28, 0x01	; 1
//la funcion de puts solo envia a putchar lo que se quiere enviar

void UART_puts(uint8_t com, char *str){

    //indicamos el caracter cero como caracter que finaliza una cadena
    while(*str != '\0'){
 294:	98 81       	ld	r25, Y
 296:	99 23       	and	r25, r25
 298:	a9 f7       	brne	.-22     	; 0x284 <UART_puts+0x14>
        UART_putchar(com, *str);
        *str++;

    }

}
 29a:	df 91       	pop	r29
 29c:	cf 91       	pop	r28
 29e:	08 95       	ret

000002a0 <UART_putchar>:



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 2a0:	e8 2f       	mov	r30, r24
 2a2:	f0 e0       	ldi	r31, 0x00	; 0
 2a4:	ee 0f       	add	r30, r30
 2a6:	ff 1f       	adc	r31, r31
 2a8:	e8 5e       	subi	r30, 0xE8	; 232
 2aa:	fd 4f       	sbci	r31, 0xFD	; 253
 2ac:	01 90       	ld	r0, Z+
 2ae:	f0 81       	ld	r31, Z
 2b0:	e0 2d       	mov	r30, r0

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 2b2:	80 81       	ld	r24, Z
 2b4:	85 ff       	sbrs	r24, 5
 2b6:	fd cf       	rjmp	.-6      	; 0x2b2 <UART_putchar+0x12>


    myUART->UDR = data;
 2b8:	66 83       	std	Z+6, r22	; 0x06


}
 2ba:	08 95       	ret

000002bc <UART_avaible>:

uint8_t UART_avaible(uint8_t com){

    //indica si RX esta disponoble

    UART_reg_t *myUART = UART_offset[com];
 2bc:	e8 2f       	mov	r30, r24
 2be:	f0 e0       	ldi	r31, 0x00	; 0
 2c0:	ee 0f       	add	r30, r30
 2c2:	ff 1f       	adc	r31, r31
 2c4:	e8 5e       	subi	r30, 0xE8	; 232
 2c6:	fd 4f       	sbci	r31, 0xFD	; 253
 2c8:	01 90       	ld	r0, Z+
 2ca:	f0 81       	ld	r31, Z
 2cc:	e0 2d       	mov	r30, r0

    //este me va a mandar 0 si el buffer esta limpio
    //vamnda 1 si hay datos sin leer dentro del buffer de RX
    return (myUART->UCSRA & (1<<RXC0));
 2ce:	80 81       	ld	r24, Z
}
 2d0:	80 78       	andi	r24, 0x80	; 128
 2d2:	08 95       	ret

000002d4 <UART_getchar>:

    //hetchar va a obtener caracter por caracter que entra por UART
    //entonces traemos de nuestros puerto UART


    UART_reg_t *myUART = UART_offset[com];
 2d4:	e8 2f       	mov	r30, r24
 2d6:	f0 e0       	ldi	r31, 0x00	; 0
 2d8:	ee 0f       	add	r30, r30
 2da:	ff 1f       	adc	r31, r31
 2dc:	e8 5e       	subi	r30, 0xE8	; 232
 2de:	fd 4f       	sbci	r31, 0xFD	; 253
 2e0:	01 90       	ld	r0, Z+
 2e2:	f0 81       	ld	r31, Z
 2e4:	e0 2d       	mov	r30, r0

    UART_reg_t *myUART = UART_offset[com];

    //este me va a mandar 0 si el buffer esta limpio
    //vamnda 1 si hay datos sin leer dentro del buffer de RX
    return (myUART->UCSRA & (1<<RXC0));
 2e6:	80 81       	ld	r24, Z


    UART_reg_t *myUART = UART_offset[com];

    //espero hsta que se termine de llenar el buffer
    while(!(UART_avaible(com)));
 2e8:	87 ff       	sbrs	r24, 7
 2ea:	fd cf       	rjmp	.-6      	; 0x2e6 <UART_getchar+0x12>

    //ahora lo que se recbibio por RX eta en el buffer, UDR por lo que ahota debemos mandarlo
    //

    return myUART->UDR;
 2ec:	86 81       	ldd	r24, Z+6	; 0x06



}
 2ee:	08 95       	ret

000002f0 <UART_gets>:


void UART_gets(uint8_t com, char *str){
 2f0:	1f 93       	push	r17
 2f2:	cf 93       	push	r28
 2f4:	df 93       	push	r29
 2f6:	ab 01       	movw	r20, r22
 2f8:	20 e0       	ldi	r18, 0x00	; 0

    //hetchar va a obtener caracter por caracter que entra por UART
    //entonces traemos de nuestros puerto UART


    UART_reg_t *myUART = UART_offset[com];
 2fa:	c8 2f       	mov	r28, r24
 2fc:	d0 e0       	ldi	r29, 0x00	; 0
 2fe:	de 01       	movw	r26, r28
 300:	aa 0f       	add	r26, r26
 302:	bb 1f       	adc	r27, r27
 304:	a8 5e       	subi	r26, 0xE8	; 232
 306:	bd 4f       	sbci	r27, 0xFD	; 253
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));


    myUART->UDR = data;
 308:	38 e0       	ldi	r19, 0x08	; 8
            //hay algo que borrar
            if(i>0){
                //el quie estaba como penuntulo ahora es el ultimo
                str[--i] = '\0';
                UART_putchar(com,'\b');
                UART_putchar(com,"");
 30a:	10 e2       	ldi	r17, 0x20	; 32
 30c:	67 e1       	ldi	r22, 0x17	; 23
 30e:	72 e0       	ldi	r23, 0x02	; 2

    //hetchar va a obtener caracter por caracter que entra por UART
    //entonces traemos de nuestros puerto UART


    UART_reg_t *myUART = UART_offset[com];
 310:	ed 91       	ld	r30, X+
 312:	fc 91       	ld	r31, X
 314:	11 97       	sbiw	r26, 0x01	; 1

    UART_reg_t *myUART = UART_offset[com];

    //este me va a mandar 0 si el buffer esta limpio
    //vamnda 1 si hay datos sin leer dentro del buffer de RX
    return (myUART->UCSRA & (1<<RXC0));
 316:	80 81       	ld	r24, Z


    UART_reg_t *myUART = UART_offset[com];

    //espero hsta que se termine de llenar el buffer
    while(!(UART_avaible(com)));
 318:	87 ff       	sbrs	r24, 7
 31a:	fd cf       	rjmp	.-6      	; 0x316 <UART_gets+0x26>

    //ahora lo que se recbibio por RX eta en el buffer, UDR por lo que ahota debemos mandarlo
    //

    return myUART->UDR;
 31c:	96 81       	ldd	r25, Z+6	; 0x06

        1-como saber que se quere terminar la cadena, con un enter

        */

        if(c == '\n' || c == '\r'){
 31e:	9a 30       	cpi	r25, 0x0A	; 10
 320:	11 f0       	breq	.+4      	; 0x326 <UART_gets+0x36>
 322:	9d 30       	cpi	r25, 0x0D	; 13
 324:	01 f5       	brne	.+64     	; 0x366 <UART_gets+0x76>
            //la cadena termina
            if(i>0){
 326:	22 23       	and	r18, r18
 328:	09 f4       	brne	.+2      	; 0x32c <UART_gets+0x3c>
 32a:	61 c0       	rjmp	.+194    	; 0x3ee <UART_gets+0xfe>
                //esta condifcion quiere decir que hay algo en al cadena, al menos 1 digito

                str[i]='\0'; //terminamso la cadena con un caracter nulo
 32c:	42 0f       	add	r20, r18
 32e:	51 1d       	adc	r21, r1
 330:	fa 01       	movw	r30, r20
 332:	10 82       	st	Z, r1



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 334:	fe 01       	movw	r30, r28
 336:	ee 0f       	add	r30, r30
 338:	ff 1f       	adc	r31, r31
 33a:	e8 5e       	subi	r30, 0xE8	; 232
 33c:	fd 4f       	sbci	r31, 0xFD	; 253
 33e:	01 90       	ld	r0, Z+
 340:	f0 81       	ld	r31, Z
 342:	e0 2d       	mov	r30, r0

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 344:	80 81       	ld	r24, Z
 346:	85 ff       	sbrs	r24, 5
 348:	fd cf       	rjmp	.-6      	; 0x344 <UART_gets+0x54>


    myUART->UDR = data;
 34a:	8d e0       	ldi	r24, 0x0D	; 13
 34c:	86 83       	std	Z+6, r24	; 0x06



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 34e:	cc 0f       	add	r28, r28
 350:	dd 1f       	adc	r29, r29
 352:	c8 5e       	subi	r28, 0xE8	; 232
 354:	dd 4f       	sbci	r29, 0xFD	; 253
 356:	e8 81       	ld	r30, Y
 358:	f9 81       	ldd	r31, Y+1	; 0x01

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 35a:	80 81       	ld	r24, Z
 35c:	85 ff       	sbrs	r24, 5
 35e:	fd cf       	rjmp	.-6      	; 0x35a <UART_gets+0x6a>


    myUART->UDR = data;
 360:	8a e0       	ldi	r24, 0x0A	; 10
 362:	86 83       	std	Z+6, r24	; 0x06
 364:	44 c0       	rjmp	.+136    	; 0x3ee <UART_gets+0xfe>


        /*
        el usuario quiere borrar algo en la pantalla
        */
        if(c == '\b'){
 366:	98 30       	cpi	r25, 0x08	; 8
 368:	e1 f4       	brne	.+56     	; 0x3a2 <UART_gets+0xb2>
            //hay algo que borrar
            if(i>0){
 36a:	22 23       	and	r18, r18
 36c:	89 f2       	breq	.-94     	; 0x310 <UART_gets+0x20>
                //el quie estaba como penuntulo ahora es el ultimo
                str[--i] = '\0';
 36e:	21 50       	subi	r18, 0x01	; 1
 370:	fa 01       	movw	r30, r20
 372:	e2 0f       	add	r30, r18
 374:	f1 1d       	adc	r31, r1
 376:	10 82       	st	Z, r1



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 378:	ed 91       	ld	r30, X+
 37a:	fc 91       	ld	r31, X
 37c:	11 97       	sbiw	r26, 0x01	; 1

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 37e:	80 81       	ld	r24, Z
 380:	85 ff       	sbrs	r24, 5
 382:	fd cf       	rjmp	.-6      	; 0x37e <UART_gets+0x8e>


    myUART->UDR = data;
 384:	36 83       	std	Z+6, r19	; 0x06



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 386:	ed 91       	ld	r30, X+
 388:	fc 91       	ld	r31, X
 38a:	11 97       	sbiw	r26, 0x01	; 1

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 38c:	80 81       	ld	r24, Z
 38e:	85 ff       	sbrs	r24, 5
 390:	fd cf       	rjmp	.-6      	; 0x38c <UART_gets+0x9c>


    myUART->UDR = data;
 392:	66 83       	std	Z+6, r22	; 0x06



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 394:	ed 91       	ld	r30, X+
 396:	fc 91       	ld	r31, X
 398:	11 97       	sbiw	r26, 0x01	; 1

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 39a:	80 81       	ld	r24, Z
 39c:	85 ff       	sbrs	r24, 5
 39e:	fd cf       	rjmp	.-6      	; 0x39a <UART_gets+0xaa>
 3a0:	24 c0       	rjmp	.+72     	; 0x3ea <UART_gets+0xfa>


    myUART->UDR = data;
 3a2:	80 81       	ld	r24, Z
 3a4:	85 ff       	sbrs	r24, 5
 3a6:	fd cf       	rjmp	.-6      	; 0x3a2 <UART_gets+0xb2>
 3a8:	96 83       	std	Z+6, r25	; 0x06
 3aa:	e2 2f       	mov	r30, r18
 3ac:	f0 e0       	ldi	r31, 0x00	; 0

        }

        //ahora sera la parte de ingresar los datos al buffer del arreglo
        UART_putchar(com,c); //imprimmismo el valor
        if(i<19){
 3ae:	23 31       	cpi	r18, 0x13	; 19
 3b0:	28 f4       	brcc	.+10     	; 0x3bc <UART_gets+0xcc>

			str[i++]= c;
 3b2:	e4 0f       	add	r30, r20
 3b4:	f5 1f       	adc	r31, r21
 3b6:	90 83       	st	Z, r25
 3b8:	2f 5f       	subi	r18, 0xFF	; 255
 3ba:	aa cf       	rjmp	.-172    	; 0x310 <UART_gets+0x20>
				esta en el indece maximo +1 entonces lo que hace es como el borraro de ese sigueitne
				caractere por lo que parece que no se esta capturando pero lo que hace es que se esta borrando
				constantement lo que se captrua despues
			*/

			str[i] = '\0'; //sustitumos el utlimo caracter con el nulo
 3bc:	e4 0f       	add	r30, r20
 3be:	f5 1f       	adc	r31, r21
 3c0:	10 82       	st	Z, r1



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 3c2:	ed 91       	ld	r30, X+
 3c4:	fc 91       	ld	r31, X
 3c6:	11 97       	sbiw	r26, 0x01	; 1

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 3c8:	80 81       	ld	r24, Z
 3ca:	85 ff       	sbrs	r24, 5
 3cc:	fd cf       	rjmp	.-6      	; 0x3c8 <UART_gets+0xd8>


    myUART->UDR = data;
 3ce:	36 83       	std	Z+6, r19	; 0x06



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 3d0:	ed 91       	ld	r30, X+
 3d2:	fc 91       	ld	r31, X
 3d4:	11 97       	sbiw	r26, 0x01	; 1

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 3d6:	80 81       	ld	r24, Z
 3d8:	85 ff       	sbrs	r24, 5
 3da:	fd cf       	rjmp	.-6      	; 0x3d6 <UART_gets+0xe6>


    myUART->UDR = data;
 3dc:	16 83       	std	Z+6, r17	; 0x06



void UART_putchar(uint8_t com, char data){

    UART_reg_t *myUART = UART_offset[com];
 3de:	ed 91       	ld	r30, X+
 3e0:	fc 91       	ld	r31, X
 3e2:	11 97       	sbiw	r26, 0x01	; 1

    //este bit de UDRE0 indca si el buffer esta preparado para recibir nueva infromacion
    //si UDREm esta en 1 el buffer esta vacio
    //entonces esta esperando a que se llene
    while(!(myUART->UCSRA & (1<<UDRE0)));
 3e4:	80 81       	ld	r24, Z
 3e6:	85 ff       	sbrs	r24, 5
 3e8:	fd cf       	rjmp	.-6      	; 0x3e4 <UART_gets+0xf4>


    myUART->UDR = data;
 3ea:	36 83       	std	Z+6, r19	; 0x06
 3ec:	91 cf       	rjmp	.-222    	; 0x310 <UART_gets+0x20>
        }



    }
}
 3ee:	df 91       	pop	r29
 3f0:	cf 91       	pop	r28
 3f2:	1f 91       	pop	r17
 3f4:	08 95       	ret

000003f6 <__udivmodsi4>:
 3f6:	a1 e2       	ldi	r26, 0x21	; 33
 3f8:	1a 2e       	mov	r1, r26
 3fa:	aa 1b       	sub	r26, r26
 3fc:	bb 1b       	sub	r27, r27
 3fe:	fd 01       	movw	r30, r26
 400:	0d c0       	rjmp	.+26     	; 0x41c <__udivmodsi4_ep>

00000402 <__udivmodsi4_loop>:
 402:	aa 1f       	adc	r26, r26
 404:	bb 1f       	adc	r27, r27
 406:	ee 1f       	adc	r30, r30
 408:	ff 1f       	adc	r31, r31
 40a:	a2 17       	cp	r26, r18
 40c:	b3 07       	cpc	r27, r19
 40e:	e4 07       	cpc	r30, r20
 410:	f5 07       	cpc	r31, r21
 412:	20 f0       	brcs	.+8      	; 0x41c <__udivmodsi4_ep>
 414:	a2 1b       	sub	r26, r18
 416:	b3 0b       	sbc	r27, r19
 418:	e4 0b       	sbc	r30, r20
 41a:	f5 0b       	sbc	r31, r21

0000041c <__udivmodsi4_ep>:
 41c:	66 1f       	adc	r22, r22
 41e:	77 1f       	adc	r23, r23
 420:	88 1f       	adc	r24, r24
 422:	99 1f       	adc	r25, r25
 424:	1a 94       	dec	r1
 426:	69 f7       	brne	.-38     	; 0x402 <__udivmodsi4_loop>
 428:	60 95       	com	r22
 42a:	70 95       	com	r23
 42c:	80 95       	com	r24
 42e:	90 95       	com	r25
 430:	9b 01       	movw	r18, r22
 432:	ac 01       	movw	r20, r24
 434:	bd 01       	movw	r22, r26
 436:	cf 01       	movw	r24, r30
 438:	08 95       	ret

0000043a <_exit>:
 43a:	f8 94       	cli

0000043c <__stop_program>:
 43c:	ff cf       	rjmp	.-2      	; 0x43c <__stop_program>
