--vamso a realzar los mismo ejercicos de TIMER0 para TIMER2 para tener encuenta eso, tanto con INT como sin INT


-TIMER0
--realizaremos un ejercicos de softPWM - PWM por medio de cualquier PIN
--relaizar un delay por medio de TIMER, vamos a podbrar por con 1 soo timer y despues PWM y delay con timer diferentes

PWM -TIMER0
DELAY-timer2

y el delay y conteo por 1 solo timer leyendo un PIN 
------------------------------------------------------

ejercicios con TIMER0 - TIMER 2
Ejercicio 2: Dos Señales con Distinta Frecuencia
Objetivo:
Generar dos señales cuadradas simultáneas:

500 Hz en OC0A (PB7).

250 Hz en OC0B (PB6).
Puntos a considerar:

Usa el modo CTC con TOP = OCR0A (la señal de menor frecuencia define el TOP).

Configura ambos pines (OC0A y OC0B) en modo toggle.

Calcula OCR0A para 250 Hz y OCR0B para 500 Hz (usa el mismo prescaler).

Asegúrate de que 
OCR0B
<
OCR0A
OCR0B<OCR0A (¿por qué?).
-----------------------

Ejercicio 4: LED con Duty Cycle Ajustable
Objetivo:
Generar una señal con duty cycle del 25% (sin PWM) en un pin digital (ej: PD0) a 10 Hz.
Puntos a considerar:

Usa dos valores distintos de OCR0A en modo CTC:

Alto: 25% del periodo.

Bajo: 75% del periodo.

Cambia el estado del pin manualmente mediante polling del flag OCF0A.

Secuencia:

Inicia con el pin en alto.

Cuando ocurra el match (OCF0A=1), pon el pin en bajo y cambia OCR0A al valor del 75%.

En el siguiente match, pon el pin en alto y restaura OCR0A al 25%.

Calcula los valores de OCR0A para cada fase (periodo total = 100 ms).
------------------

Ejercicio 1: Generación de Señal PWM con TIMER0 (Fast PWM)
Enunciado:
Configura TIMER0 en modo Fast PWM para generar una señal PWM en el pin OC0A (PD6 en ATmega328P) con una frecuencia de ~62.5 kHz (usando reloj de 16 MHz). Varía el ciclo de trabajo gradualmente del 0% al 100% y viceversa, usando retardos no bloqueantes.
Partes Clave:

Cálculo del preescaler (usar preescaler 1 para lograr la frecuencia deseada).

Configuración de registro TCCR0A (modo Fast PWM, no-invertido).

Uso del registro OCR0A para controlar el duty cycle.
------------------

Ejercicio 2: Modulación PWM en TIMER2 (Phase Correct PWM)
Enunciado:
Configura TIMER2 en modo Phase Correct PWM en el pin OC2B (PD3) con una frecuencia de ~31.4 kHz (16 MHz). Realiza un barrido automático del duty cycle desde 25% hasta 75% y regresa, con una transición suave cada 500 ms.
Partes Clave:

Preescaler adecuado (usar preescaler 8).

Registro TCCR2A (modo Phase Correct PWM, no-invertido).

Relación entre el valor de OCR2B y el duty cycle.

--------------------------

Ejercicio 3: Contador por Overflow con TIMER0 (Modo Normal)
Enunciado:
Usa TIMER0 en modo normal para generar una interrupción por overflow cada ~16 ms (con preescaler 1024). Haz parpadear un LED cada segundo usando un contador de sobreflujos.
Partes Clave:

Cálculo de tiempo de overflow: T_overflow = (256 * preescaler) / F_CPU.

Habilitar interrupción TIMER0_OVF.

Contador de overflows para lograr 1 segundo (62 overflows ≈ 1 s).

----------------------------

Ejercicio 4: Generación de Tonos con TIMER2 (Modo CTC)
Enunciado:
Configura TIMER2 en modo CTC (Clear Timer on Compare) para generar un tono de 1 kHz en un buzzer conectado a OC2B (PD3). Usa la salida de comparación para toggle automático del pin.
Partes Clave:

Fórmula para calcular OCR2A: OCR2A = (F_CPU / (2 * preescaler * frecuencia)) - 1.

Preescaler recomendado: 64.

Configuración de TCCR2A para toggle en compare match (COM2B0).

---------------------

Ejercicio 5: PWM Sincronizado con Dos Timers (TIMER0 + TIMER2)
Enunciado:
Sincroniza TIMER0 (Fast PWM en OC0A) y TIMER2 (Phase Correct PWM en OC2B). El duty cycle de TIMER2 debe incrementarse un 5% cada vez que el ciclo de TIMER0 alcance el 100%.
Partes Clave:

Usar interrupción por overflow de TIMER0 para actualizar OCR2B.

Lógica de sincronización:

Cuando OCR0A = 255 (100% duty cycle), incrementar OCR2B en 13 (5% de 255).

Evitar desbordamientos en OCR2B.

-----------------


Notas Técnicas:
Fast PWM vs Phase Correct PWM:

Fast PWM: Frecuencia alta, transiciones rápidas (ideal para control de motores).

Phase Correct PWM: Frecuencia reducida a la mitad, simetría perfecta (ideal para audio).

Registros Clave:

TCCRXA/TCCRXB: Control de modo y preescaler.

OCRXA/OCRXB: Valores de comparación (duty cycle).

TIMSKX: Habilitar interrupciones.

Fórmulas Útiles:

PWM: frecuencia = F_CPU / (preescaler * 256) (Fast PWM).

CTC: frecuencia = F_CPU / (2 * preescaler * (OCR2A + 1)).

---------------

"Retardos no bloqueantes" se refiere a una técnica de programación que permite realizar pausas o esperas sin 
detener la ejecución del resto del programa. Es clave en sistemas embebidos para mantener la capacidad de respuesta 
del sistema mientras se gestionan tareas temporizadas. Aquí la explicación detallada:





-------------------------------------------------------------------------------

formulas a considerar 

TIMER- conteo 

conocer el #ticks para x tiempo 

F_timer = F_osc / PS -> F_osc = Frecuecinia del oscilador (16MHz) - PS - prescaldor (depende del timer)

F_tikcs = 1/F_timer - cual es la frecueicnia de los ticks del timer 

#ticks = time / F_ticks -> el numero de ticks para que pase (time -  tiempo estimado {numero que quepa en 8 bits para timer0 y timer2})



-FAST_PWM 


cuando TOP = MAX (0xFF - 255)

las frecuencias del PWM solo pueden ser aplicadas las que nos da los prescaladores del TIMER

  F_PWM = Fosc / PS * TOP

  F_PWM = 16MHZ / 8 * 256 = 7812.5 Hz

    F_PWM = 16MHZ / 64 * 256 = 976.56 Hz -> VAMOS A ELEIR ESTE

    F_PWM = 16MHZ / 256 * 256 = 244.14 Hz

    F_PWM = 16MHZ / 1024 * 256 = 61.03 Hz

calcular OCR0A (donde OCR0A indica el diclo de trabajo)

-cycle_duty = (OCRxn + 1) / 256 * 100%

-OCRxn = ((duty_cycle * 256 )/100) - 1


-FAST_PWM cunado TOP = OCRxA

-F_PWM = Fosc / (PS * (OCRxA + 1))

-OCRxA = (Focs / (F_PWM * PS )) - 1

- para calcular el ciclo de trabajo seria: 

OCRxB = ((duty_cycle /100) * 256) -1




---
Corret phase PWM

TOP = MAX -> (0xFF - 255)

cunado TOP es MAX la frecueicnas del PWM estan relacionadas estrechamente con los prescaldores donde OCRxA indica
el ciclo de trabajo

F_PC_PWM = F_osc / PS * 510 


-ciclo de tranajo 

duty_cicle = (OCRxA / 255 ) * 100% -> OCRxA = (duty_cycle * 255 ) / 100



--

correct phase PWM 

TOP = OCRxA 

cunado el TOP es OCRxA quiere decir que la frecuecnia del PWM es dado por ese registros 
ahora el ciclode trabajo sigue siendo la misma formual pero ahora esta definido por OCRxB 


->frecueicnias 

F_PWM = F_osc / PS * 2 * OCRxA -> OCRxA = F_osc / 2 * PS * F_PWM 

-> ciclo de trabajo

duty_cycle = (OCRxB / OCRxA) * 100% -> OCRxB = (duty_cycle * 0CRxA) / 100 

--------------------------------------

ADC


->como leer los datos cunado ADLAR = 0 - los 8 bits menos significativos estan en ADCL y 2 bit MSB en ADCH

la lectura seria como 

uint8_t high = ADCH;
uint8_t low = ADCL;

uint16_t resultado = (hight << 8) | low;

->supongamos que en una lectrua leemos 1023 -> < 11 1111 1111 >

-por lo que tenemos 

-> ADCL = 1111 1111 - (0xFF)
-> ADCH = 0000 0011 - (0x03)

-> por lo que lo que hacemos es que la parte alta la recorremos 8 espacios dejando espacio para introducir ADCL

-> 0x03 << 8 -> 0000 0011 0000 00000 -> recordando que es una varibale de 16 bits

por lo que ahora: 

-> 0x0300 | 0x00FF = 0x03FF -> 1023 como resultado de los 10 bits del ADC











 












