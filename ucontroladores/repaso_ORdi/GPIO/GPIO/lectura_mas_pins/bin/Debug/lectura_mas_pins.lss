
bin\Debug\lectura_mas_pins.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002be  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .bss          00000001  00800200  00800200  00000352  2**0
                  ALLOC
  2 .fuse         00000003  00820000  00820000  00000352  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  3 .debug_aranges 00000020  00000000  00000000  00000355  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000080  00000000  00000000  00000375  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000001c9  00000000  00000000  000003f5  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 0000013f  00000000  00000000  000005be  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000248  00000000  00000000  000006fd  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000060  00000000  00000000  00000948  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000130  00000000  00000000  000009a8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 72 00 	jmp	0xe4	; 0xe4 <__ctors_end>
   4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
   c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  10:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  14:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  18:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  1c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  20:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  24:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  28:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  2c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  30:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  34:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  38:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  3c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  40:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  44:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  48:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  4c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  50:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  54:	0c 94 d5 00 	jmp	0x1aa	; 0x1aa <__vector_21>
  58:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  5c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  60:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  64:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  68:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  6c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  70:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  74:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  78:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  7c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  80:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  84:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  88:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  8c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  90:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  94:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  98:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  9c:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  a8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  ac:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  b8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  bc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  c8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  cc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d4:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  d8:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  dc:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>
  e0:	0c 94 93 00 	jmp	0x126	; 0x126 <__bad_interrupt>

000000e4 <__ctors_end>:
  e4:	11 24       	eor	r1, r1
  e6:	1f be       	out	0x3f, r1	; 63
  e8:	cf ef       	ldi	r28, 0xFF	; 255
  ea:	d1 e2       	ldi	r29, 0x21	; 33
  ec:	de bf       	out	0x3e, r29	; 62
  ee:	cd bf       	out	0x3d, r28	; 61
  f0:	00 e0       	ldi	r16, 0x00	; 0
  f2:	0c bf       	out	0x3c, r16	; 60

000000f4 <__do_copy_data>:
  f4:	12 e0       	ldi	r17, 0x02	; 2
  f6:	a0 e0       	ldi	r26, 0x00	; 0
  f8:	b2 e0       	ldi	r27, 0x02	; 2
  fa:	ee eb       	ldi	r30, 0xBE	; 190
  fc:	f2 e0       	ldi	r31, 0x02	; 2
  fe:	00 e0       	ldi	r16, 0x00	; 0
 100:	0b bf       	out	0x3b, r16	; 59
 102:	02 c0       	rjmp	.+4      	; 0x108 <__do_copy_data+0x14>
 104:	07 90       	elpm	r0, Z+
 106:	0d 92       	st	X+, r0
 108:	a0 30       	cpi	r26, 0x00	; 0
 10a:	b1 07       	cpc	r27, r17
 10c:	d9 f7       	brne	.-10     	; 0x104 <__do_copy_data+0x10>

0000010e <__do_clear_bss>:
 10e:	12 e0       	ldi	r17, 0x02	; 2
 110:	a0 e0       	ldi	r26, 0x00	; 0
 112:	b2 e0       	ldi	r27, 0x02	; 2
 114:	01 c0       	rjmp	.+2      	; 0x118 <.do_clear_bss_start>

00000116 <.do_clear_bss_loop>:
 116:	1d 92       	st	X+, r1

00000118 <.do_clear_bss_start>:
 118:	a1 30       	cpi	r26, 0x01	; 1
 11a:	b1 07       	cpc	r27, r17
 11c:	e1 f7       	brne	.-8      	; 0x116 <.do_clear_bss_loop>
 11e:	0e 94 3b 01 	call	0x276	; 0x276 <main>
 122:	0c 94 5d 01 	jmp	0x2ba	; 0x2ba <_exit>

00000126 <__bad_interrupt>:
 126:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000012a <GPIO_init>:
    led2,
    led3
};


void GPIO_init(){
 12a:	df 93       	push	r29
 12c:	cf 93       	push	r28
 12e:	cd b7       	in	r28, 0x3d	; 61
 130:	de b7       	in	r29, 0x3e	; 62

//parte alta del puerto F como salida

//sabemos que para tener pins de entrada deben estos estar en 1 y activamos pull ups internos
    //con 1 activamos el pull up interno
    DDRF &=~(7<<PF0);
 132:	a0 e3       	ldi	r26, 0x30	; 48
 134:	b0 e0       	ldi	r27, 0x00	; 0
 136:	e0 e3       	ldi	r30, 0x30	; 48
 138:	f0 e0       	ldi	r31, 0x00	; 0
 13a:	80 81       	ld	r24, Z
 13c:	88 7f       	andi	r24, 0xF8	; 248
 13e:	8c 93       	st	X, r24
    PORTF |=(7<<PF0);
 140:	a1 e3       	ldi	r26, 0x31	; 49
 142:	b0 e0       	ldi	r27, 0x00	; 0
 144:	e1 e3       	ldi	r30, 0x31	; 49
 146:	f0 e0       	ldi	r31, 0x00	; 0
 148:	80 81       	ld	r24, Z
 14a:	87 60       	ori	r24, 0x07	; 7
 14c:	8c 93       	st	X, r24



    //acctivamos pa parte alta como salida

    DDRF |= (7<<PF3);
 14e:	a0 e3       	ldi	r26, 0x30	; 48
 150:	b0 e0       	ldi	r27, 0x00	; 0
 152:	e0 e3       	ldi	r30, 0x30	; 48
 154:	f0 e0       	ldi	r31, 0x00	; 0
 156:	80 81       	ld	r24, Z
 158:	88 63       	ori	r24, 0x38	; 56
 15a:	8c 93       	st	X, r24

}
 15c:	cf 91       	pop	r28
 15e:	df 91       	pop	r29
 160:	08 95       	ret

00000162 <TIMER_init>:


void TIMER_init(){
 162:	df 93       	push	r29
 164:	cf 93       	push	r28
 166:	cd b7       	in	r28, 0x3d	; 61
 168:	de b7       	in	r29, 0x3e	; 62


    sei();
 16a:	78 94       	sei

    //como CTC

    TCCR0A |= (1<<WGM01);
 16c:	a4 e4       	ldi	r26, 0x44	; 68
 16e:	b0 e0       	ldi	r27, 0x00	; 0
 170:	e4 e4       	ldi	r30, 0x44	; 68
 172:	f0 e0       	ldi	r31, 0x00	; 0
 174:	80 81       	ld	r24, Z
 176:	82 60       	ori	r24, 0x02	; 2
 178:	8c 93       	st	X, r24

    #ticks =  time / F_Timer = 1ms / 4 uS = 250 -> 1 ms

    */

    TCCR0B |= (1<<CS00) | (1<<CS01);
 17a:	a5 e4       	ldi	r26, 0x45	; 69
 17c:	b0 e0       	ldi	r27, 0x00	; 0
 17e:	e5 e4       	ldi	r30, 0x45	; 69
 180:	f0 e0       	ldi	r31, 0x00	; 0
 182:	80 81       	ld	r24, Z
 184:	83 60       	ori	r24, 0x03	; 3
 186:	8c 93       	st	X, r24

    //activamos las interrupciones

    TIMSK0 |= (1<<OCIE0A);
 188:	ae e6       	ldi	r26, 0x6E	; 110
 18a:	b0 e0       	ldi	r27, 0x00	; 0
 18c:	ee e6       	ldi	r30, 0x6E	; 110
 18e:	f0 e0       	ldi	r31, 0x00	; 0
 190:	80 81       	ld	r24, Z
 192:	82 60       	ori	r24, 0x02	; 2
 194:	8c 93       	st	X, r24

    OCR0A = 250 -1;
 196:	e7 e4       	ldi	r30, 0x47	; 71
 198:	f0 e0       	ldi	r31, 0x00	; 0
 19a:	89 ef       	ldi	r24, 0xF9	; 249
 19c:	80 83       	st	Z, r24
    TCNT0 =0;
 19e:	e6 e4       	ldi	r30, 0x46	; 70
 1a0:	f0 e0       	ldi	r31, 0x00	; 0
 1a2:	10 82       	st	Z, r1


}
 1a4:	cf 91       	pop	r28
 1a6:	df 91       	pop	r29
 1a8:	08 95       	ret

000001aa <__vector_21>:


ISR(TIMER0_COMPA_vect){
 1aa:	1f 92       	push	r1
 1ac:	0f 92       	push	r0
 1ae:	0f b6       	in	r0, 0x3f	; 63
 1b0:	0f 92       	push	r0
 1b2:	11 24       	eor	r1, r1
 1b4:	8f 93       	push	r24
 1b6:	df 93       	push	r29
 1b8:	cf 93       	push	r28
 1ba:	cd b7       	in	r28, 0x3d	; 61
 1bc:	de b7       	in	r29, 0x3e	; 62

    delay_pin++;
 1be:	80 91 00 02 	lds	r24, 0x0200
 1c2:	8f 5f       	subi	r24, 0xFF	; 255
 1c4:	80 93 00 02 	sts	0x0200, r24
}
 1c8:	cf 91       	pop	r28
 1ca:	df 91       	pop	r29
 1cc:	8f 91       	pop	r24
 1ce:	0f 90       	pop	r0
 1d0:	0f be       	out	0x3f, r0	; 63
 1d2:	0f 90       	pop	r0
 1d4:	1f 90       	pop	r1
 1d6:	18 95       	reti

000001d8 <read_btn>:




uint8_t read_btn(){
 1d8:	df 93       	push	r29
 1da:	cf 93       	push	r28
 1dc:	0f 92       	push	r0
 1de:	cd b7       	in	r28, 0x3d	; 61
 1e0:	de b7       	in	r29, 0x3e	; 62
    //como leemos el PIN?, debemos de enmascaras si es que se esta leyendo cada pin

    //antes que nada debemos verificar si es que algo se esta lenyendo

    //no se que pin se esta precionando pero alguno lo esta
    if(!(PINF & (7<<PF0))!= 0){
 1e2:	ef e2       	ldi	r30, 0x2F	; 47
 1e4:	f0 e0       	ldi	r31, 0x00	; 0
 1e6:	80 81       	ld	r24, Z
 1e8:	88 2f       	mov	r24, r24
 1ea:	90 e0       	ldi	r25, 0x00	; 0
 1ec:	87 70       	andi	r24, 0x07	; 7
 1ee:	90 70       	andi	r25, 0x00	; 0
 1f0:	00 97       	sbiw	r24, 0x00	; 0
 1f2:	d9 f5       	brne	.+118    	; 0x26a <read_btn+0x92>

        //esperamos a que delay llegue a 100 mS
        while(delay_pin < 100);
 1f4:	80 91 00 02 	lds	r24, 0x0200
 1f8:	84 36       	cpi	r24, 0x64	; 100
 1fa:	e0 f3       	brcs	.-8      	; 0x1f4 <read_btn+0x1c>

        delay_pin = 0;
 1fc:	10 92 00 02 	sts	0x0200, r1

        //pin
        if(!(PINF & (1<<PF0))){
 200:	ef e2       	ldi	r30, 0x2F	; 47
 202:	f0 e0       	ldi	r31, 0x00	; 0
 204:	80 81       	ld	r24, Z
 206:	88 2f       	mov	r24, r24
 208:	90 e0       	ldi	r25, 0x00	; 0
 20a:	81 70       	andi	r24, 0x01	; 1
 20c:	90 70       	andi	r25, 0x00	; 0
 20e:	00 97       	sbiw	r24, 0x00	; 0
 210:	41 f4       	brne	.+16     	; 0x222 <read_btn+0x4a>
            //delay para leer el PIN
            while(delay_pin < 100);
 212:	80 91 00 02 	lds	r24, 0x0200
 216:	84 36       	cpi	r24, 0x64	; 100
 218:	e0 f3       	brcs	.-8      	; 0x212 <read_btn+0x3a>
            delay_pin = 0;
 21a:	10 92 00 02 	sts	0x0200, r1
            return led1;
 21e:	19 82       	std	Y+1, r1	; 0x01
 220:	25 c0       	rjmp	.+74     	; 0x26c <read_btn+0x94>
        }

        if(!(PINF & (1<<PF1))){
 222:	ef e2       	ldi	r30, 0x2F	; 47
 224:	f0 e0       	ldi	r31, 0x00	; 0
 226:	80 81       	ld	r24, Z
 228:	88 2f       	mov	r24, r24
 22a:	90 e0       	ldi	r25, 0x00	; 0
 22c:	82 70       	andi	r24, 0x02	; 2
 22e:	90 70       	andi	r25, 0x00	; 0
 230:	00 97       	sbiw	r24, 0x00	; 0
 232:	49 f4       	brne	.+18     	; 0x246 <read_btn+0x6e>
            while(delay_pin < 100);
 234:	80 91 00 02 	lds	r24, 0x0200
 238:	84 36       	cpi	r24, 0x64	; 100
 23a:	e0 f3       	brcs	.-8      	; 0x234 <read_btn+0x5c>
            delay_pin = 0;
 23c:	10 92 00 02 	sts	0x0200, r1
            return led2;
 240:	81 e0       	ldi	r24, 0x01	; 1
 242:	89 83       	std	Y+1, r24	; 0x01
 244:	13 c0       	rjmp	.+38     	; 0x26c <read_btn+0x94>
        }

        if(!(PINF & (1<<PF2))){
 246:	ef e2       	ldi	r30, 0x2F	; 47
 248:	f0 e0       	ldi	r31, 0x00	; 0
 24a:	80 81       	ld	r24, Z
 24c:	88 2f       	mov	r24, r24
 24e:	90 e0       	ldi	r25, 0x00	; 0
 250:	84 70       	andi	r24, 0x04	; 4
 252:	90 70       	andi	r25, 0x00	; 0
 254:	00 97       	sbiw	r24, 0x00	; 0
 256:	49 f4       	brne	.+18     	; 0x26a <read_btn+0x92>
            while(delay_pin < 100);
 258:	80 91 00 02 	lds	r24, 0x0200
 25c:	84 36       	cpi	r24, 0x64	; 100
 25e:	e0 f3       	brcs	.-8      	; 0x258 <read_btn+0x80>
            delay_pin = 0;
 260:	10 92 00 02 	sts	0x0200, r1
            return led3;
 264:	82 e0       	ldi	r24, 0x02	; 2
 266:	89 83       	std	Y+1, r24	; 0x01
 268:	01 c0       	rjmp	.+2      	; 0x26c <read_btn+0x94>
        }
    }

    return 0; //no se esta leyendo nada
 26a:	19 82       	std	Y+1, r1	; 0x01
 26c:	89 81       	ldd	r24, Y+1	; 0x01

}
 26e:	0f 90       	pop	r0
 270:	cf 91       	pop	r28
 272:	df 91       	pop	r29
 274:	08 95       	ret

00000276 <main>:




int main(void)
{
 276:	df 93       	push	r29
 278:	cf 93       	push	r28
 27a:	0f 92       	push	r0
 27c:	cd b7       	in	r28, 0x3d	; 61
 27e:	de b7       	in	r29, 0x3e	; 62

    GPIO_init(); //INCIALIZAR PUERTOS
 280:	0e 94 95 00 	call	0x12a	; 0x12a <GPIO_init>

    TIMER_init(); //inicalizar timer
 284:	0e 94 b1 00 	call	0x162	; 0x162 <TIMER_init>

    // Insert code

    while(1){

        btn = read_btn();
 288:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <read_btn>
 28c:	89 83       	std	Y+1, r24	; 0x01

        if(btn == led1){
 28e:	89 81       	ldd	r24, Y+1	; 0x01
 290:	88 23       	and	r24, r24
 292:	21 f4       	brne	.+8      	; 0x29c <main+0x26>
            0000 0111 <- actual
            0000 1111
            F0

            salida = 00xx 1x*/
            PORTF =(0x0F<<PF0);
 294:	e1 e3       	ldi	r30, 0x31	; 49
 296:	f0 e0       	ldi	r31, 0x00	; 0
 298:	8f e0       	ldi	r24, 0x0F	; 15
 29a:	80 83       	st	Z, r24

        }

        if(btn == led2){
 29c:	89 81       	ldd	r24, Y+1	; 0x01
 29e:	81 30       	cpi	r24, 0x01	; 1
 2a0:	21 f4       	brne	.+8      	; 0x2aa <main+0x34>
            0001 0111 < - 0x17

            0001 0 111
            */

            PORTF = (0x17<<PF0);
 2a2:	e1 e3       	ldi	r30, 0x31	; 49
 2a4:	f0 e0       	ldi	r31, 0x00	; 0
 2a6:	87 e1       	ldi	r24, 0x17	; 23
 2a8:	80 83       	st	Z, r24
        }

        if(btn == led3){
 2aa:	89 81       	ldd	r24, Y+1	; 0x01
 2ac:	82 30       	cpi	r24, 0x02	; 2
 2ae:	61 f7       	brne	.-40     	; 0x288 <main+0x12>
            /*
            0010 0111
            27

            */
            PORTF = (0x27 << PF0);
 2b0:	e1 e3       	ldi	r30, 0x31	; 49
 2b2:	f0 e0       	ldi	r31, 0x00	; 0
 2b4:	87 e2       	ldi	r24, 0x27	; 39
 2b6:	80 83       	st	Z, r24
 2b8:	e7 cf       	rjmp	.-50     	; 0x288 <main+0x12>

000002ba <_exit>:
 2ba:	f8 94       	cli

000002bc <__stop_program>:
 2bc:	ff cf       	rjmp	.-2      	; 0x2bc <__stop_program>
